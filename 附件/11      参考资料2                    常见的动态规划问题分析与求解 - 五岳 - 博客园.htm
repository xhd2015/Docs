<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="zh-cn"><head><script src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/latex.htm" async=""></script>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>常见的动态规划问题分析与求解 - 五岳 - 博客园</title>
<link type="text/css" rel="stylesheet" href="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/blog-common.css">
<link id="MainCss" type="text/css" rel="stylesheet" href="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/bundle-marvin2-brown.css">
<link type="text/css" rel="stylesheet" href="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/80216.css">
<link title="RSS" type="application/rss+xml" rel="alternate" href="http://www.cnblogs.com/wuyuegb2312/rss">
<link title="RSD" type="application/rsd+xml" rel="EditURI" href="http://www.cnblogs.com/wuyuegb2312/rsd.xml">
<link type="application/wlwmanifest+xml" rel="wlwmanifest" href="http://www.cnblogs.com/wuyuegb2312/wlwmanifest.xml">
<script src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/encoder.js" type="text/javascript"></script><script src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/jquery.js" type="text/javascript"></script>  
<script type="text/javascript">var currentBlogApp = 'wuyuegb2312', cb_enable_mathjax=false;</script>
<script src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/blog-common.js" type="text/javascript"></script>
</head>
<body>
<a name="top"></a>
<div id="page_begin_html"><div style="display: none" id="__document_write_ajax_div-1"></div></div><script>load_page_begin_html();</script>

<div id="top">

<h1><a id="Header1_HeaderTitle" class="headermaintitle" href="http://www.cnblogs.com/wuyuegb2312/">Cyberspace_TechNode</a></h1>
<p id="tagline">虚心学习 专注 豁达</p>
</div>
<div id="leftmenu">

	
<h3>导航</h3>
<ul>
	<li>
		<a id="MyLinks1_HomeLink" href="http://www.cnblogs.com/">博客园</a>
	</li><li><a id="MyLinks1_MyHomeLink" href="http://www.cnblogs.com/wuyuegb2312/">首页</a></li>
	<li><a id="MyLinks1_NewPostLink" rel="nofollow" href="http://i.cnblogs.com/EditPosts.aspx?opt=1">新随笔</a></li>
	<li>
		<a id="MyLinks1_ContactLink" accesskey="9" rel="nofollow" href="http://msg.cnblogs.com/send/%E4%BA%94%E5%B2%B3">联系</a>
	</li><li>
		<a id="MyLinks1_Syndication" href="http://www.cnblogs.com/wuyuegb2312/rss">订阅</a><a id="MyLinks1_XMLLink" href="http://www.cnblogs.com/wuyuegb2312/rss"><img src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/xml.gif" alt="订阅"></a>
	</li><li>
		<a id="MyLinks1_Admin" rel="nofollow" href="http://i.cnblogs.com/">管理</a></li>
</ul>

	<div id="blog-calendar" style=""><table id="blogCalendar" class="Cal" title="Calendar" cellpadding="0" cellspacing="0">
	<tbody><tr><td colspan="7"><table class="CalTitle" cellspacing="0">
		<tbody><tr><td class="CalNextPrev"><a href="javascript:void(0);" onclick="loadBlogCalendar('2016/06/01');return false;">&lt;</a></td><td align="center">2016年7月</td><td class="CalNextPrev" align="right"><a href="javascript:void(0);" onclick="loadBlogCalendar('2016/08/01');return false;">&gt;</a></td></tr>
	</tbody></table></td></tr><tr><th class="CalDayHeader" abbr="日" scope="col" align="center">日</th><th class="CalDayHeader" abbr="一" scope="col" align="center">一</th><th class="CalDayHeader" abbr="二" scope="col" align="center">二</th><th class="CalDayHeader" abbr="三" scope="col" align="center">三</th><th class="CalDayHeader" abbr="四" scope="col" align="center">四</th><th class="CalDayHeader" abbr="五" scope="col" align="center">五</th><th class="CalDayHeader" abbr="六" scope="col" align="center">六</th></tr><tr><td class="CalOtherMonthDay" align="center">26</td><td class="CalOtherMonthDay" align="center">27</td><td class="CalOtherMonthDay" align="center">28</td><td class="CalOtherMonthDay" align="center">29</td><td class="CalOtherMonthDay" align="center">30</td><td align="center">1</td><td class="CalWeekendDay" align="center">2</td></tr><tr><td class="CalWeekendDay" align="center">3</td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">7</td><td align="center">8</td><td class="CalWeekendDay" align="center">9</td></tr><tr><td class="CalWeekendDay" align="center">10</td><td align="center">11</td><td align="center">12</td><td align="center">13</td><td align="center">14</td><td align="center">15</td><td class="CalTodayDay" align="center">16</td></tr><tr><td class="CalWeekendDay" align="center">17</td><td align="center">18</td><td align="center">19</td><td align="center">20</td><td align="center">21</td><td align="center">22</td><td class="CalWeekendDay" align="center">23</td></tr><tr><td class="CalWeekendDay" align="center">24</td><td align="center">25</td><td align="center">26</td><td align="center">27</td><td align="center">28</td><td align="center">29</td><td class="CalWeekendDay" align="center">30</td></tr><tr><td class="CalWeekendDay" align="center">31</td><td class="CalOtherMonthDay" align="center">1</td><td class="CalOtherMonthDay" align="center">2</td><td class="CalOtherMonthDay" align="center">3</td><td class="CalOtherMonthDay" align="center">4</td><td class="CalOtherMonthDay" align="center">5</td><td class="CalOtherMonthDay" align="center">6</td></tr>
</tbody></table></div><script type="text/javascript">loadBlogDefaultCalendar();</script>
	
<h3>统计</h3>
<ul>
	<li>
		随笔 -
		115
	</li><li>
		文章 -
		38
	</li><li>
		评论 -
		236
	</li><li>
		引用 -
		0
	</li>
</ul>

	
<h3>公告</h3>
	<div id="blog-news"><!--访问计数-->
<a href="http://info.flagcounter.com/O664"><img src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/a.png" alt="Flag Counter" border="0"></a>
since July 10, 2013<div id="profile_block">昵称：<a href="http://home.cnblogs.com/u/wuyuegb2312/">五岳</a><br>园龄：<a href="http://home.cnblogs.com/u/wuyuegb2312/" title="入园时间：2010-12-05">5年7个月</a><br>粉丝：<a href="http://home.cnblogs.com/u/wuyuegb2312/followers/">419</a><br>关注：<a href="http://home.cnblogs.com/u/wuyuegb2312/followees/">14</a><div id="p_b_follow"><a href="javascript:void(0);" onclick="cnblogs.UserManager.FollowBlogger('03b9a8f9-1a00-e011-ac81-842b2b196315')">+加关注</a></div></div></div><script type="text/javascript">loadBlogNews();</script>

	<div id="blog-sidecolumn"><div id="sidebar_search" class="sidebar-block">
<div id="sidebar_search" class="mySearch">
<h3 class="catListTitle">搜索</h3>
<div id="sidebar_search_box">
<div id="widget_my_zzk" class="div_my_zzk"><input id="q" onkeydown="return zzk_go_enter(event);" class="input_my_zzk" type="text">&nbsp;<input onclick="zzk_go()" value="找找看" id="btnZzk" class="btn_my_zzk" type="button"></div>
<div id="widget_my_google" class="div_my_zzk"><input name="google_q" id="google_q" onkeydown="return google_go_enter(event)" class="input_my_zzk" type="text">&nbsp;<input onclick="google_go()" value="谷歌搜索" class="btn_my_zzk" type="button"></div>
</div>
</div>

</div><div id="sidebar_shortcut" class="sidebar-block">
<h3 class="catListTitle">常用链接</h3>
<ul>
<li><a href="http://www.cnblogs.com/wuyuegb2312/p/" title="我的博客的随笔列表">我的随笔</a></li><li><a href="http://www.cnblogs.com/wuyuegb2312/MyComments.html" title="我发表过的评论列表">我的评论</a></li><li><a href="http://www.cnblogs.com/wuyuegb2312/OtherPosts.html" title="我评论过的随笔列表">我的参与</a></li><li><a href="http://www.cnblogs.com/wuyuegb2312/RecentComments.html" title="我的博客的评论列表">最新评论</a></li><li><a href="http://www.cnblogs.com/wuyuegb2312/tag/" title="我的博客的标签列表">我的标签</a></li>
</ul>
<div id="itemListLin_con" style="display:none;">

</div></div><div id="sidebar_toptags" class="sidebar-block">
<h3 class="catListTitle">我的标签</h3>
<div id="MyTag">
<ul>
<li><a href="http://www.cnblogs.com/wuyuegb2312/tag/%E7%AE%97%E6%B3%95/">算法</a>(13)</li><li><a href="http://www.cnblogs.com/wuyuegb2312/tag/%E9%9D%A2%E8%AF%95/">面试</a>(7)</li><li><a href="http://www.cnblogs.com/wuyuegb2312/tag/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>(6)</li><li><a href="http://www.cnblogs.com/wuyuegb2312/tag/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/">编程之美</a>(5)</li><li><a href="http://www.cnblogs.com/wuyuegb2312/tag/Java/">Java</a>(4)</li><li><a href="http://www.cnblogs.com/wuyuegb2312/tag/nginx/">nginx</a>(4)</li><li><a href="http://www.cnblogs.com/wuyuegb2312/tag/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">现代操作系统</a>(4)</li><li><a href="http://www.cnblogs.com/wuyuegb2312/tag/Linux/">Linux</a>(3)</li><li><a href="http://www.cnblogs.com/wuyuegb2312/tag/%E5%88%86%E6%B2%BB%E6%B3%95/">分治法</a>(2)</li><li><a href="http://www.cnblogs.com/wuyuegb2312/tag/%E7%BB%86%E8%8A%82/">细节</a>(2)</li><li><a href="http://www.cnblogs.com/wuyuegb2312/tag/">更多</a></li>
</ul>
</div></div><div id="sidebar_categories">
		<h3>随笔分类<span style="font-size:11px;font-weight:normal">(265)</span></h3>
		
				<ul>
			
				<li><a id="CatList_LinkList_0_Link_0" href="http://www.cnblogs.com/wuyuegb2312/category/335634.html">C(31)</a> </li>
			
				<li><a id="CatList_LinkList_0_Link_1" href="http://www.cnblogs.com/wuyuegb2312/category/390198.html">C++(3)</a> </li>
			
				<li><a id="CatList_LinkList_0_Link_2" href="http://www.cnblogs.com/wuyuegb2312/category/598827.html">DB(1)</a> </li>
			
				<li><a id="CatList_LinkList_0_Link_3" href="http://www.cnblogs.com/wuyuegb2312/category/741895.html">Git(1)</a> </li>
			
				<li><a id="CatList_LinkList_0_Link_4" href="http://www.cnblogs.com/wuyuegb2312/category/593710.html">Java(7)</a> </li>
			
				<li><a id="CatList_LinkList_0_Link_5" href="http://www.cnblogs.com/wuyuegb2312/category/335633.html">Linux/Unix(31)</a> </li>
			
				<li><a id="CatList_LinkList_0_Link_6" href="http://www.cnblogs.com/wuyuegb2312/category/392974.html">Linux内核(7)</a> </li>
			
				<li><a id="CatList_LinkList_0_Link_7" href="http://www.cnblogs.com/wuyuegb2312/category/508153.html">nginx(4)</a> </li>
			
				<li><a id="CatList_LinkList_0_Link_8" href="http://www.cnblogs.com/wuyuegb2312/category/445245.html">Python(3)</a> </li>
			
				<li><a id="CatList_LinkList_0_Link_9" href="http://www.cnblogs.com/wuyuegb2312/category/313894.html">Simulink(6)</a> </li>
			
				<li><a id="CatList_LinkList_0_Link_10" href="http://www.cnblogs.com/wuyuegb2312/category/476925.html">笔试面试题(11)</a> </li>
			
				<li><a id="CatList_LinkList_0_Link_11" href="http://www.cnblogs.com/wuyuegb2312/category/496410.html">编程之美(5)</a> </li>
			
				<li><a id="CatList_LinkList_0_Link_12" href="http://www.cnblogs.com/wuyuegb2312/category/530080.html">操作系统(10)</a> </li>
			
				<li><a id="CatList_LinkList_0_Link_13" href="http://www.cnblogs.com/wuyuegb2312/category/414331.html">机器学习/神经网络(3)</a> </li>
			
				<li><a id="CatList_LinkList_0_Link_14" href="http://www.cnblogs.com/wuyuegb2312/category/402349.html">嵌入式(2)</a> </li>
			
				<li><a id="CatList_LinkList_0_Link_15" href="http://www.cnblogs.com/wuyuegb2312/category/348326.html">软件开发(10)</a> </li>
			
				<li><a id="CatList_LinkList_0_Link_16" href="http://www.cnblogs.com/wuyuegb2312/category/416678.html">算法(23)</a> </li>
			
				<li><a id="CatList_LinkList_0_Link_17" href="http://www.cnblogs.com/wuyuegb2312/category/313895.html">网络编程(19)</a> </li>
			
				<li><a id="CatList_LinkList_0_Link_18" href="http://www.cnblogs.com/wuyuegb2312/category/308360.html">学习笔记(56)</a> </li>
			
				<li><a id="CatList_LinkList_0_Link_19" href="http://www.cnblogs.com/wuyuegb2312/category/488845.html">珠玑之椟(7)</a> </li>
			
				<li><a id="CatList_LinkList_0_Link_20" href="http://www.cnblogs.com/wuyuegb2312/category/310855.html">资料收集(25)</a> </li>
			
				</ul>
			
	
		<h3>随笔档案<span style="font-size:11px;font-weight:normal">(115)</span></h3>
		
				<ul>
			
				<li><a id="CatList_LinkList_1_Link_0" href="http://www.cnblogs.com/wuyuegb2312/archive/2015/11.html">2015年11月 (1)</a> </li>
			
				<li><a id="CatList_LinkList_1_Link_1" href="http://www.cnblogs.com/wuyuegb2312/archive/2015/05.html">2015年5月 (1)</a> </li>
			
				<li><a id="CatList_LinkList_1_Link_2" href="http://www.cnblogs.com/wuyuegb2312/archive/2015/04.html">2015年4月 (1)</a> </li>
			
				<li><a id="CatList_LinkList_1_Link_3" href="http://www.cnblogs.com/wuyuegb2312/archive/2015/03.html">2015年3月 (2)</a> </li>
			
				<li><a id="CatList_LinkList_1_Link_4" href="http://www.cnblogs.com/wuyuegb2312/archive/2015/02.html">2015年2月 (2)</a> </li>
			
				<li><a id="CatList_LinkList_1_Link_5" href="http://www.cnblogs.com/wuyuegb2312/archive/2015/01.html">2015年1月 (1)</a> </li>
			
				<li><a id="CatList_LinkList_1_Link_6" href="http://www.cnblogs.com/wuyuegb2312/archive/2014/07.html">2014年7月 (1)</a> </li>
			
				<li><a id="CatList_LinkList_1_Link_7" href="http://www.cnblogs.com/wuyuegb2312/archive/2014/04.html">2014年4月 (1)</a> </li>
			
				<li><a id="CatList_LinkList_1_Link_8" href="http://www.cnblogs.com/wuyuegb2312/archive/2014/02.html">2014年2月 (3)</a> </li>
			
				<li><a id="CatList_LinkList_1_Link_9" href="http://www.cnblogs.com/wuyuegb2312/archive/2013/12.html">2013年12月 (2)</a> </li>
			
				<li><a id="CatList_LinkList_1_Link_10" href="http://www.cnblogs.com/wuyuegb2312/archive/2013/11.html">2013年11月 (8)</a> </li>
			
				<li><a id="CatList_LinkList_1_Link_11" href="http://www.cnblogs.com/wuyuegb2312/archive/2013/10.html">2013年10月 (3)</a> </li>
			
				<li><a id="CatList_LinkList_1_Link_12" href="http://www.cnblogs.com/wuyuegb2312/archive/2013/09.html">2013年9月 (2)</a> </li>
			
				<li><a id="CatList_LinkList_1_Link_13" href="http://www.cnblogs.com/wuyuegb2312/archive/2013/08.html">2013年8月 (12)</a> </li>
			
				<li><a id="CatList_LinkList_1_Link_14" href="http://www.cnblogs.com/wuyuegb2312/archive/2013/07.html">2013年7月 (9)</a> </li>
			
				<li><a id="CatList_LinkList_1_Link_15" href="http://www.cnblogs.com/wuyuegb2312/archive/2013/06.html">2013年6月 (9)</a> </li>
			
				<li><a id="CatList_LinkList_1_Link_16" href="http://www.cnblogs.com/wuyuegb2312/archive/2013/05.html">2013年5月 (4)</a> </li>
			
				<li><a id="CatList_LinkList_1_Link_17" href="http://www.cnblogs.com/wuyuegb2312/archive/2013/04.html">2013年4月 (3)</a> </li>
			
				<li><a id="CatList_LinkList_1_Link_18" href="http://www.cnblogs.com/wuyuegb2312/archive/2013/03.html">2013年3月 (5)</a> </li>
			
				<li><a id="CatList_LinkList_1_Link_19" href="http://www.cnblogs.com/wuyuegb2312/archive/2013/02.html">2013年2月 (1)</a> </li>
			
				<li><a id="CatList_LinkList_1_Link_20" href="http://www.cnblogs.com/wuyuegb2312/archive/2013/01.html">2013年1月 (1)</a> </li>
			
				<li><a id="CatList_LinkList_1_Link_21" href="http://www.cnblogs.com/wuyuegb2312/archive/2012/12.html">2012年12月 (3)</a> </li>
			
				<li><a id="CatList_LinkList_1_Link_22" href="http://www.cnblogs.com/wuyuegb2312/archive/2012/11.html">2012年11月 (1)</a> </li>
			
				<li><a id="CatList_LinkList_1_Link_23" href="http://www.cnblogs.com/wuyuegb2312/archive/2012/10.html">2012年10月 (1)</a> </li>
			
				<li><a id="CatList_LinkList_1_Link_24" href="http://www.cnblogs.com/wuyuegb2312/archive/2012/09.html">2012年9月 (2)</a> </li>
			
				<li><a id="CatList_LinkList_1_Link_25" href="http://www.cnblogs.com/wuyuegb2312/archive/2012/08.html">2012年8月 (2)</a> </li>
			
				<li><a id="CatList_LinkList_1_Link_26" href="http://www.cnblogs.com/wuyuegb2312/archive/2012/07.html">2012年7月 (3)</a> </li>
			
				<li><a id="CatList_LinkList_1_Link_27" href="http://www.cnblogs.com/wuyuegb2312/archive/2012/06.html">2012年6月 (3)</a> </li>
			
				<li><a id="CatList_LinkList_1_Link_28" href="http://www.cnblogs.com/wuyuegb2312/archive/2012/05.html">2012年5月 (3)</a> </li>
			
				<li><a id="CatList_LinkList_1_Link_29" href="http://www.cnblogs.com/wuyuegb2312/archive/2012/04.html">2012年4月 (1)</a> </li>
			
				<li><a id="CatList_LinkList_1_Link_30" href="http://www.cnblogs.com/wuyuegb2312/archive/2012/01.html">2012年1月 (3)</a> </li>
			
				<li><a id="CatList_LinkList_1_Link_31" href="http://www.cnblogs.com/wuyuegb2312/archive/2011/12.html">2011年12月 (1)</a> </li>
			
				<li><a id="CatList_LinkList_1_Link_32" href="http://www.cnblogs.com/wuyuegb2312/archive/2011/11.html">2011年11月 (3)</a> </li>
			
				<li><a id="CatList_LinkList_1_Link_33" href="http://www.cnblogs.com/wuyuegb2312/archive/2011/09.html">2011年9月 (3)</a> </li>
			
				<li><a id="CatList_LinkList_1_Link_34" href="http://www.cnblogs.com/wuyuegb2312/archive/2011/08.html">2011年8月 (3)</a> </li>
			
				<li><a id="CatList_LinkList_1_Link_35" href="http://www.cnblogs.com/wuyuegb2312/archive/2011/07.html">2011年7月 (11)</a> </li>
			
				</ul>
			
	
		<h3>相册<span style="font-size:11px;font-weight:normal">(31)</span></h3>
		
				<ul>
			
				<li><a id="CatList_LinkList_2_Link_0" href="http://www.cnblogs.com/wuyuegb2312/gallery/468244.html" rel="nofollow">《大话设计模式》配图(24)</a> </li>
			
				<li><a id="CatList_LinkList_2_Link_1" href="http://www.cnblogs.com/wuyuegb2312/gallery/476799.html" rel="nofollow">malloc配图(2)</a> </li>
			
				<li><a id="CatList_LinkList_2_Link_2" href="http://www.cnblogs.com/wuyuegb2312/gallery/434601.html" rel="nofollow">VC维(3)</a> </li>
			
				<li><a id="CatList_LinkList_2_Link_3" href="http://www.cnblogs.com/wuyuegb2312/gallery/470412.html" rel="nofollow">vi(1)</a> </li>
			
				<li><a id="CatList_LinkList_2_Link_4" href="http://www.cnblogs.com/wuyuegb2312/gallery/323588.html" rel="nofollow">博客贴图(1)</a> </li>
			
				</ul>
			
	
		<h3>常用资料</h3>
		
				<ul>
			
				<li><a id="CatList_LinkList_3_Link_0" href="http://lxr.linux.no/" rel="nofollow" target="_blank">Linux Cross Reference</a> </li>
			
				<li><a id="CatList_LinkList_3_Link_1" href="http://linux.die.net/" rel="nofollow">Linux在线手册</a> </li>
			
				<li><a id="CatList_LinkList_3_Link_2" href="http://www.appinn.com/markdown/" rel="nofollow">Markdown语法</a> </li>
			
				<li><a id="CatList_LinkList_3_Link_3" href="http://mahua.jser.me/" rel="nofollow">Markdown在线编辑器</a> </li>
			
				<li><a id="CatList_LinkList_3_Link_4" href="http://www.ilovematlab.cn/index.php" rel="nofollow">MATLAB中文论坛</a> </li>
			
				<li><a id="CatList_LinkList_3_Link_5" href="http://www.cdecl.org/" rel="nofollow" target="_blank">在线C定义解释</a> </li>
			<li class="c_b_p_link_desc">可以解释各类型的定义，简单的如整型、浮点型，复杂的如数组、函数指针等。</li>
				<li><a id="CatList_LinkList_3_Link_6" href="http://www.codecogs.com/latex/eqneditor.php" rel="nofollow" target="_blank">在线LaTex转换</a> </li>
			
				<li><a id="CatList_LinkList_3_Link_7" href="http://www.masswerk.at/jsuix/index.html" rel="nofollow" target="_blank">在线Shell (1)</a> </li>
			
				<li><a id="CatList_LinkList_3_Link_8" href="http://www.goosh.org/" rel="nofollow" target="_blank">在线Shell (2)</a> </li>
			
				<li><a id="CatList_LinkList_3_Link_9" href="http://www.6wm.cn/16_10/index.php" rel="nofollow">在线进制转换</a> </li>
			
				</ul>
			
	
		<h3>友链</h3>
		
				<ul>
			
				<li><a id="CatList_LinkList_4_Link_0" href="http://www.ifdong.com/" rel="nofollow">dariusdong</a> </li>
			
				<li><a id="CatList_LinkList_4_Link_1" href="http://www.findshine.com/" rel="nofollow">Shen Fan(范深)</a> </li>
			
				</ul>
			
	</div><div id="sidebar_scorerank" class="sidebar-block">
<h3>积分与排名</h3>
<ul>
	<li>
		积分 -
		168037
	</li><li>
		排名 -
		1048
	</li>
</ul>
</div><div id="sidebar_recentcomments" class="sidebar-block"><div id="recent_comments_wrap">
<h3 class="catListTitle">最新评论</h3>
<div class="RecentComment" id="RecentComments">
	<div id="RecentCommentsBlock"><ul>
        <li class="recent_comment_title"><a href="http://www.cnblogs.com/wuyuegb2312/p/3136831.html#3466273">1. Re:[珠玑之椟]位向量/位图的定义和应用</a></li>
        <li class="recent_comment_body">@ErnastoChenfixed...</li>
        <li class="recent_comment_author">--五岳</li>
        <li class="recent_comment_title"><a href="http://www.cnblogs.com/wuyuegb2312/p/3226771.html#3465412">2. Re:《深入理解Nginx》阅读与实践（一）：Nginx安装配置与HelloWorld</a></li>
        <li class="recent_comment_body">@五岳谢谢...</li>
        <li class="recent_comment_author">--ROBOT巍巍</li>
        <li class="recent_comment_title"><a href="http://www.cnblogs.com/wuyuegb2312/p/3226771.html#3465017">3. Re:《深入理解Nginx》阅读与实践（一）：Nginx安装配置与HelloWorld</a></li>
        <li class="recent_comment_body">@ROBOT巍巍...</li>
        <li class="recent_comment_author">--五岳</li>
</ul>
</div>
</div>
</div></div><div id="sidebar_topviewedposts" class="sidebar-block"><div id="topview_posts_wrap">
<h3 class="catListTitle">阅读排行榜</h3>
<div class="RecentComment" id="TopViewPosts"> 
	<div id="TopViewPostsBlock"><ul><li><a href="http://www.cnblogs.com/wuyuegb2312/p/3872607.html">1. 通过JDBC进行简单的增删改查（以MySQL为例）(67953)</a></li><li><a href="http://www.cnblogs.com/wuyuegb2312/archive/2013/06/08/3126510.html">2. 轻松记住大端小端的含义（附对大端和小端的解释）(24089)</a></li><li><a href="http://www.cnblogs.com/wuyuegb2312/p/3399566.html">3. 手把手教你编写一个具有基本功能的shell（已开源）(20587)</a></li><li><a href="http://www.cnblogs.com/wuyuegb2312/archive/2013/04/09/3008320.html">4. 《大话设计模式》Python版代码实现(18139)</a></li><li><a href="http://www.cnblogs.com/wuyuegb2312/archive/2013/02/26/2910908.html">5. 《Python学习手册》读书笔记(15669)</a></li></ul></div>
</div>
</div></div><div id="sidebar_topcommentedposts" class="sidebar-block"><div id="topfeedback_posts_wrap">
<h3 class="catListTitle">评论排行榜</h3>
<div class="RecentComment" id="TopCommentsPosts">
	<div id="TopFeedbackPostsBlock"><ul><li><a href="http://www.cnblogs.com/wuyuegb2312/p/3399566.html">1. 手把手教你编写一个具有基本功能的shell（已开源）(22)</a></li><li><a href="http://www.cnblogs.com/wuyuegb2312/archive/2013/05/26/3090369.html">2. 如何写出正确的二分查找？——利用循环不变式理解二分查找及其变体的正确性以及构造方式(19)</a></li><li><a href="http://www.cnblogs.com/wuyuegb2312/p/3219659.html">3. malloc()参数为0的情况(15)</a></li><li><a href="http://www.cnblogs.com/wuyuegb2312/archive/2011/11/16/2250144.html">4. 《C陷阱与缺陷》学习笔记（上）：词法陷阱、语法陷阱、语义陷阱(14)</a></li><li><a href="http://www.cnblogs.com/wuyuegb2312/archive/2013/04/09/3008320.html">5. 《大话设计模式》Python版代码实现(13)</a></li></ul></div>
</div></div></div><div id="sidebar_topdiggedposts" class="sidebar-block"><div id="topdigg_posts_wrap">
<h3 class="catListTitle">推荐排行榜</h3>
<div class="RecentComment">
	<div id="TopDiggPostsBlock"><ul><li><a href="http://www.cnblogs.com/wuyuegb2312/archive/2013/04/09/3008320.html">1. 《大话设计模式》Python版代码实现(21)</a></li><li><a href="http://www.cnblogs.com/wuyuegb2312/p/3872607.html">2. 通过JDBC进行简单的增删改查（以MySQL为例）(17)</a></li><li><a href="http://www.cnblogs.com/wuyuegb2312/p/3016878.html">3. 从《编程之美》买票找零问题说起，娓娓道来卡特兰数——兼爬坑指南(16)</a></li><li><a href="http://www.cnblogs.com/wuyuegb2312/p/3281264.html">4. 常见的动态规划问题分析与求解(14)</a></li><li><a href="http://www.cnblogs.com/wuyuegb2312/p/3399566.html">5. 手把手教你编写一个具有基本功能的shell（已开源）(11)</a></li></ul></div>
</div></div></div></div><script type="text/javascript">loadBlogSideColumn();</script>

</div>
<div id="main">
	
<div id="post_detail">
	<div class="post">
		<h2>
			<a id="cb_post_title_url" href="http://www.cnblogs.com/wuyuegb2312/p/3281264.html">常见的动态规划问题分析与求解</a>
		</h2>
		<div id="cnblogs_post_body"><p>　　动态规划（Dynamic Programming，简称DP），虽然抽象后进行求解的思路并不复杂，但具体的形式千差万别，找出问题的子结构以及通过子结构重新构造最优解的过程很难统一，并不像回溯法具有解决绝大多数问题的银弹（<a id="cb_post_title_url" href="http://www.cnblogs.com/wuyuegb2312/p/3273337.html">全面解析回溯法：算法框架与问题求解</a>)。为了解决动态规划问题，只能靠多练习、多思考了。<span style="color: #0000ff;">本文主要是对一些常见的动态规划题目的收集</span>，希望能有所帮助。难度评级受个人主观影响较大，仅供参考。</p>
<p>&nbsp;</p>
<p style="margin-left: 60px;">目录（点击跳转）</p>
<p style="margin-left: 60px;"><a href="#i1">动态规划求解的一般思路</a></p>
<p style="margin-left: 60px;"><a href="#i2"><span>备忘录法</span></a></p>
<p style="margin-left: 60px;"><a href="#q1"><span>1.硬币找零</span></a></p>
<p style="margin-left: 60px;">　　<a href="#q1a1">扩展1：单路取苹果</a></p>
<p style="margin-left: 60px;">　　<a href="#q1a2">扩展2：装配线调度</a></p>
<p style="margin-left: 60px;"><a href="#q2"><span>2.字符串相似度/编辑距离（edit distance）</span></a></p>
<p style="margin-left: 60px;">　　<a href="#q2a1">应用1：子串匹配</a></p>
<p style="margin-left: 60px;">　　<a href="#q2a2">应用2：最长公共子序列</a></p>
<p style="margin-left: 60px;"><a href="#q3"><span>3.</span>最长公共子序列(Longest Common Subsequence,lcs)</a></p>
<p style="margin-left: 60px;">　　<a href="#q3a1"><span>扩展1：输出所有lcs</span></a></p>
<p style="margin-left: 60px;">　　<a href="#q3a2">扩展2：通过LCS获得最长递增自子序列</a></p>
<p style="margin-left: 60px;"><a href="#q4"><span>4.</span>最长递增子序列（Longest Increasing Subsequence,lis）</a></p>
<p style="margin-left: 60px;">　　<a href="#q4a">扩展：求解lis的加速</a></p>
<p style="margin-left: 60px;"><a href="#q5">5.<span>最大连续子序列和/积</span></a></p>
<p style="margin-left: 60px;">　　<a href="#q5a1">扩展1：正浮点数数组求最大连续子序列积</a></p>
<p style="margin-left: 60px;">　　<a href="#q5a2">扩展2：任意浮点数数组求最大连续子序列积</a></p>
<p style="margin-left: 60px;"><a href="#q6"><span>6.矩阵链乘法</span></a></p>
<p style="margin-left: 60px;">　　<a href="#q6a">扩展：矩阵链乘法的备忘录解法（伪码）</a></p>
<p style="margin-left: 60px;"><a href="#q7"><span>7.0-1背包问题</span></a></p>
<p style="margin-left: 60px;"><a href="#q8"><span>8.有代价的最短路径</span></a></p>
<p style="margin-left: 60px;"><a href="#q9"><span>9.瓷砖覆盖（状态压缩DP）</span></a></p>
<p style="margin-left: 60px;"><a href="#q10"><span>10.工作量划分</span></a></p>
<p style="margin-left: 60px;"><a href="#q11"><span>11.三路取苹果</span></a></p>
<p style="margin-left: 60px;"><a href="#ref"><span>参考资料</span></a></p>
<p style="margin-left: 60px;"><a href="#a1"><span>附录1：其他的一些动态规划问题与解答（链接）</span></a></p>
<p style="margin-left: 60px;"><a href="#a2"><span>附录2：《算法设计手册》第八章 动态规划 面试题解答</span></a></p>
<p>&nbsp;</p>
<p><a name="i1"></a>动态规划求解的一般思路：&nbsp;</p>
<p>　　<span style="font-size: 16px;">判断问题的</span><span style="font-size: 16px;">子结构（也可看作状态），当具有最优子结构时，动态规划可能适用。</span></p>
<p><span style="font-size: 16px;">　　求解重叠子问题。一个递归算法不断地调用同一问题，</span><span style="font-size: 16px;">递归可以转化为查表从而利用子问题的解。分治法则不同，每次递归都产生新的问题。</span></p>
<p><span style="font-size: 16px;">　　重新构造一个最优解。</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 16px;"><a name="i2"></a>备忘录法：</span></p>
<p><span style="font-size: 16px;">　　动态规划的一种变形，使用自顶向下的策略，更像递归算法。</span></p>
<p><span style="font-size: 16px;">　　初始化时表中填入一个特殊值表示待填入，当递归算法第一次遇到一个子问题时，计算并填表；以后每次遇到时只需返回以前填入的值。</span></p>
<p><span style="font-size: 16px;">　　实例可以参照矩阵链乘法部分。&nbsp;</span></p>
<p>&nbsp;</p>
<h1><span style="font-size: 18pt;"><a name="q1"></a>1.硬币找零</span></h1>
<p><span>难度评级：★</span></p>
<p><span style="font-size: 16px;">　　假设有几种硬币，如1、3、5，并且数量无限。请找出能够组成某个数目的找零所使用最少的硬币数。&nbsp;</span></p>
<p><span style="font-size: 16px;">解法：</span></p>
<p><span style="font-size: 16px;">　　用待找零的数值k描述<strong>子结构</strong>/<strong>状态</strong>，
记作sum[k]，其值为所需的最小硬币数。对于不同的硬币面值coin[0...n]，有sum[k] = min(sum[k-coin[0]] ,
 sum[k-coin[1]], ...)+1。对应于给定数目的找零total，需要求解sum[total]的值。</span></p>
<div class="cnblogs_code">
<pre>typedef <span style="color: #0000ff;">struct</span><span style="color: #000000;"> {
    </span><span style="color: #0000ff;">int</span> nCoin; <span style="color: #008000;">//</span><span style="color: #008000;">使用硬币数量
    </span><span style="color: #008000;">//</span><span style="color: #008000;">以下两个成员是为了便于构造出求解过程的展示</span>
    <span style="color: #0000ff;">int</span> lastSum;<span style="color: #008000;">//</span><span style="color: #008000;">上一个状态</span>
    <span style="color: #0000ff;">int</span> addCoin;<span style="color: #008000;">//</span><span style="color: #008000;">从上一个状态达到当前状态所用的硬币种类</span>
} state;</pre>
</div>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/copycode.gif" alt="复制代码"></a></span></div>
<pre>state *sum = malloc(<span style="color: #0000ff;">sizeof</span>(state)*(total+<span style="color: #800080;">1</span><span style="color: #000000;">));

</span><span style="color: #008000;">//</span><span style="color: #008000;">init</span>
<span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">0</span>;i&lt;=total;i++<span style="color: #000000;">) 
    sum[i].nCoin </span>=<span style="color: #000000;"> INF;
sum[</span><span style="color: #800080;">0</span>].nCoin = <span style="color: #800080;">0</span><span style="color: #000000;">;
sum[</span><span style="color: #800080;">0</span>].lastSum = <span style="color: #800080;">0</span><span style="color: #000000;">;

</span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">1</span>;i&lt;=total;i++<span style="color: #000000;">)
    </span><span style="color: #0000ff;">for</span>(j=<span style="color: #800080;">0</span>;j&lt;n;j++<span style="color: #000000;">)
        </span><span style="color: #0000ff;">if</span>(i-coin[j]&gt;=<span style="color: #800080;">0</span> &amp;&amp; sum[i-coin[j]].nCoin+<span style="color: #800080;">1</span>&lt;<span style="color: #000000;">sum[i].nCoin)
        {
            sum[i].nCoin </span>= sum[i-coin[j]].nCoin+<span style="color: #800080;">1</span><span style="color: #000000;">;
            sum[i].lastSum </span>=<span style="color: #000000;"> j;
            sum[i].addCoin </span>=<span style="color: #000000;"> coin[j];
        }

    </span><span style="color: #0000ff;">if</span>(sum[total].nCoin ==<span style="color: #000000;"> INF) 
    {
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">can't make change.\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">else</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">output<br>　　　　<span style="color: #000000;">;</span><br></span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p><span style="font-size: 16px;">　　通过sum[total].lastSum和sum[total].addCoin，很容易通过循环逆序地或者编写递归调用的函数正序地输出从结束状态到开始状态使用的硬币种类。以下各题输出状态转换的方法同样，不再赘述。下面为了方便起见，有的题没有在构造子结构的解时记录状态转换，如果需要请类似地完成。</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 16px;">扩展：</span></p>
<p><span style="font-size: 16px;"><a name="q1a1"></a>(1)一个矩形区域被划分为N*M个小矩形格子，在格子(i,j)中有A[i][j]个苹果。现在从左上角的格子(1,1)出发，要求每次只能向右走一步或向下走一步，最后到达(N,M)，每经过一个格子就把其中的苹果全部拿走。请找出能拿到最多苹果数的路线。</span></p>
<p><span style="font-size: 16px;"><span>难度评级：★</span></span></p>
<p><span style="font-size: 16px;">分析：</span></p>
<p><span style="font-size: 16px;">　　这道题中，当前位置(i,j)是<strong>状态</strong>，用M[i][j]来表示到达状态(i,j)所能得到的最多苹果数，那么M[i][j] = max(M[i-1][j],M[i][j-1]) + A[i][j] 。特殊情况是M[1][1]=A[1][1]，当i=1且j!=1时,M[i][j] = M[i][j-1] + A[i][j]；当i!=1且j=1时M[i][j] = M[i-1][j] + A[i][j]。</span></p>
<p><span style="font-size: 16px;">　　求解程序略。</span></p>
<p>&nbsp;</p>
<p><a name="q1a2"></a>(2)装配线调度（《算法导论》15.1）</p>
<p><span>难度评级：★</span></p>
<p>　　<img src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/26110902-6ee30ae49aae417980cbeeb07376056d.jpg" alt=""></p>
<p>　　</p>
<h1><span style="font-size: 18pt;"><a name="q2"></a>2.字符串相似度/编辑距离（edit distance）</span></h1>
<p><span style="font-size: 16px;">难度评级：★</span></p>
<p><span style="font-size: 16px;">　　对于序列S和T，它们之间距离定义为：对二者其一进行几次以下的操作(1)删去一个字符；(2)插入一个字符；(3)改变一个字符。每进行一次操作，计数增加1。将S和T变为同一个字符串的最小计数即为它们的距离。给出相应算法。</span></p>
<p><span style="font-size: 16px;">解法：</span></p>
<p><span style="font-size: 16px;">　　将S和T的长度分别记为len(S)和len(T)，并把S和T的距离记为m[len(S)][len(T)]，有以下几种情况：</span></p>
<p style="margin-left: 60px;"><span style="font-size: 16px;">如果末尾字符相同，那么<span>m[len(S)][len(T)]=<span>m[len(S)-1][len(T)-1]；</span></span></span></p>
<p style="margin-left: 60px;"><span style="font-size: 16px;"><span><span>如果末尾字符不同，有以下处理方式</span></span></span></p>
<p style="margin-left: 60px;"><span style="font-size: 16px;"><span><span>　　修改S或T末尾字符使其与另一个一致来完成，<span>m[len(S)][len(T)]=</span><span>m[len(S)-1][len(T)-1]+1；</span></span></span></span></p>
<p style="margin-left: 60px;"><span style="font-size: 16px;"><span><span><span>　　在S末尾插入T末尾的字符，比较S[1...<span>len(S)</span>]和S[1...len(T)-1]；</span></span></span></span></p>
<p style="margin-left: 60px;"><span style="font-size: 16px;"><span><span><span><span>　　在T末尾插入S末尾的字符，比较S[1...</span><span>len(S)-1</span><span>]和S[1...len(T)]；</span></span></span></span></span></p>
<p style="margin-left: 60px;"><span style="font-size: 16px;"><span><span><span><span>　　删除S末尾的字符，比较<span>S[1...</span><span>len(S)-1</span><span>]和S[1...len(T)]；</span></span></span></span></span></span></p>
<p style="margin-left: 60px;"><span style="font-size: 16px;"><span><span><span><span><span><span>　　删除T末尾的字符，比较</span><span>S[1...</span><span>len(S)</span><span>]和S[1...len(T)-1]；</span></span></span></span></span></span></span></p>
<p><span style="font-size: 16px;">　　总结为，对于i&gt;0,j&gt;0的状态(i,j),m[i][j] = min( m[i-1][j-1]+(s[i]==s[j])?0:1 , m[i-1][j]+1, m[i][j-1] +1)。</span></p>
<p><span style="font-size: 16px;">　　这里的<strong><span style="color: #000000;">重叠子结构</span></strong>是S[1...i]，T[1...j]。</span></p>
<p>　　以下是相应代码。考虑到C语言数组下标从0开始，做了一个转化将字符串后移一位。</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('aabd63bb-c323-4e93-b353-3271448ae0f6')"><img id="code_img_closed_aabd63bb-c323-4e93-b353-3271448ae0f6" class="code_img_closed" src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/ContractedBlock.gif" alt=""><img id="code_img_opened_aabd63bb-c323-4e93-b353-3271448ae0f6" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('aabd63bb-c323-4e93-b353-3271448ae0f6',event)" src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/ExpandedBlockStart.gif" alt="">
<div id="cnblogs_code_open_aabd63bb-c323-4e93-b353-3271448ae0f6" class="cnblogs_code_hide">
<pre>#include &lt;stdio.h&gt;<span style="color: #000000;">
#include </span>&lt;<span style="color: #0000ff;">string</span>.h&gt;
<span style="color: #0000ff;">#define</span> MAXLEN 20
<span style="color: #0000ff;">#define</span> MATCH 0
<span style="color: #0000ff;">#define</span> INSERT 1
<span style="color: #0000ff;">#define</span> DELETE 2<span style="color: #000000;">

typedef </span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> {
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> cost;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> parent;
} cell;

cell m[MAXLEN</span>+<span style="color: #800080;">1</span>][MAXLEN+<span style="color: #800080;">1</span><span style="color: #000000;">];

</span><span style="color: #0000ff;">int</span> match(<span style="color: #0000ff;">char</span> a,<span style="color: #0000ff;">char</span><span style="color: #000000;"> b)
{
    </span><span style="color: #008000;">//</span><span style="color: #008000;">cost of match
    </span><span style="color: #008000;">//</span><span style="color: #008000;">match:    0
    </span><span style="color: #008000;">//</span><span style="color: #008000;">not match:1</span>
    <span style="color: #0000ff;">return</span> (a==b)?<span style="color: #800080;">0</span>:<span style="color: #800080;">1</span><span style="color: #000000;">;
}

</span><span style="color: #0000ff;">int</span> string_compare(<span style="color: #0000ff;">char</span> *s,<span style="color: #0000ff;">char</span> *<span style="color: #000000;">t)
{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i,j,k;
    </span><span style="color: #0000ff;">int</span> opt[<span style="color: #800080;">3</span><span style="color: #000000;">];
    
    </span><span style="color: #008000;">//</span><span style="color: #008000;">row_init(i);</span>
    <span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">0</span>;i&lt;=MAXLEN;i++<span style="color: #000000;">) {
        m[i][</span><span style="color: #800080;">0</span>].cost =<span style="color: #000000;"> i;
        </span><span style="color: #0000ff;">if</span>(i==<span style="color: #800080;">0</span><span style="color: #000000;">)
            m[i][</span><span style="color: #800080;">0</span>].parent = -<span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;">
            m[i][</span><span style="color: #800080;">0</span>].parent =<span style="color: #000000;"> INSERT;
    }

    </span><span style="color: #008000;">//</span><span style="color: #008000;">column_init(i);</span>
    <span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">0</span>;i&lt;=MAXLEN;i++<span style="color: #000000;">) {
        m[</span><span style="color: #800080;">0</span>][i].cost =<span style="color: #000000;"> i;
        </span><span style="color: #0000ff;">if</span>(i==<span style="color: #800080;">0</span><span style="color: #000000;">)
            </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;">
            m[</span><span style="color: #800080;">0</span>][i].parent =<span style="color: #000000;"> INSERT;
    }
    
    </span><span style="color: #0000ff;">char</span> m_s[MAXLEN+<span style="color: #800080;">1</span>] = <span style="color: #800000;">"</span> <span style="color: #800000;">"</span>,m_t[MAXLEN+<span style="color: #800080;">1</span>] =<span style="color: #800000;">"</span> <span style="color: #800000;">"</span><span style="color: #000000;">;
    strcat(m_s,s);
    strcat(m_t,t);

    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">1</span>;i&lt;=strlen(s);i++<span style="color: #000000;">)
    {
        </span><span style="color: #0000ff;">for</span>(j=<span style="color: #800080;">1</span>;j&lt;=strlen(t);j++<span style="color: #000000;">) {
            opt[MATCH] </span>= m[i-<span style="color: #800080;">1</span>][j-<span style="color: #800080;">1</span>].cost +<span style="color: #000000;"> match(m_s[i],m_t[j]);
            opt[INSERT] </span>= m[i][j-<span style="color: #800080;">1</span>].cost + <span style="color: #800080;">1</span><span style="color: #000000;">;
            opt[DELETE] </span>= m[i-<span style="color: #800080;">1</span>][j].cost + <span style="color: #800080;">1</span><span style="color: #000000;">;
            m[i][j].cost </span>=<span style="color: #000000;"> opt[MATCH];
            m[i][j].parent </span>=<span style="color: #000000;"> MATCH;
            </span><span style="color: #0000ff;">for</span>(k=INSERT;k&lt;=DELETE;k++<span style="color: #000000;">)
                </span><span style="color: #0000ff;">if</span>(opt[k]&lt;<span style="color: #000000;">m[i][j].cost)
                {
                    m[i][j].cost </span>=<span style="color: #000000;"> opt[k];
                    m[i][j].parent </span>=<span style="color: #000000;"> k;
                }
        }
    }
    i</span>--,j--<span style="color: #000000;">;
    </span><span style="color: #008000;">//</span><span style="color: #008000;">goal_cell(s,t,&amp;i,&amp;j);</span>
    <span style="color: #0000ff;">return</span><span style="color: #000000;"> m[i][j].cost;
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main() {
    </span><span style="color: #0000ff;">char</span> t[] = <span style="color: #800000;">"</span><span style="color: #800000;">you should not</span><span style="color: #800000;">"</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">char</span> p[] = <span style="color: #800000;">"</span><span style="color: #800000;">thou shalt not</span><span style="color: #800000;">"</span><span style="color: #000000;">;

    </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> string_compare(t,p);
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,n);
}</span></pre>
</div>
<span class="cnblogs_code_collapse">字符串相似度/edit distance</span></div>
<p>&nbsp;</p>
<p>应用：</p>
<p><a name="q2a1"></a>　　(1)子串匹配</p>
<p>　　<span>难度评级：★★</span></p>
<p>　　修改两处即可进行子串匹配：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('fdf46b28-0c2b-4294-8bcb-b96d85d2a360')"><img id="code_img_closed_fdf46b28-0c2b-4294-8bcb-b96d85d2a360" class="code_img_closed" src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/ContractedBlock.gif" alt=""><img id="code_img_opened_fdf46b28-0c2b-4294-8bcb-b96d85d2a360" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('fdf46b28-0c2b-4294-8bcb-b96d85d2a360',event)" src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/ExpandedBlockStart.gif" alt="">
<div id="cnblogs_code_open_fdf46b28-0c2b-4294-8bcb-b96d85d2a360" class="cnblogs_code_hide">
<pre>row_init(<span style="color: #0000ff;">int</span><span style="color: #000000;"> i)
{
    m[</span><span style="color: #800080;">0</span>][i].cost = <span style="color: #800080;">0</span>; <span style="color: #008000;">/*</span><span style="color: #008000;"> note change </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    m[</span><span style="color: #800080;">0</span>][i].parent = -<span style="color: #800080;">1</span>; <span style="color: #008000;">/*</span><span style="color: #008000;"> note change </span><span style="color: #008000;">*/</span><span style="color: #000000;">
}

goal_cell(</span><span style="color: #0000ff;">char</span> *s, <span style="color: #0000ff;">char</span> *t, <span style="color: #0000ff;">int</span> *i, <span style="color: #0000ff;">int</span> *<span style="color: #000000;">j)
{
    </span><span style="color: #0000ff;">int</span> k; <span style="color: #008000;">/*</span><span style="color: #008000;"> counter </span><span style="color: #008000;">*/</span>
    *i = strlen(s) - <span style="color: #800080;">1</span><span style="color: #000000;">;
    </span>*j = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span> (k=<span style="color: #800080;">1</span>; k&lt;strlen(t); k++<span style="color: #000000;">)
        </span><span style="color: #0000ff;">if</span> (m[*i][k].cost &lt; m[*i][*j].cost) *j =<span style="color: #000000;"> k;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">修改部分</span></div>
<p>　　如果j= strlen(S) - strlen(T)，那么说明T是S的一个子串。</p>
<p>　　（这部分是根据《算法设计手册》8.2.4和具体实例Skiena与Skienaa、Skiena与somta的分析获得的，解释不够全面，可能有误，请注意）</p>
<p>&nbsp;</p>
<p><a name="q2a2"></a>　　(2)最长公共子序列</p>
<p>　　难度评级：★★</p>
<p>　　将match时不匹配的代价转化为最大长度即可：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('47687689-81a9-47c5-8577-87522cdfd00e')"><img id="code_img_closed_47687689-81a9-47c5-8577-87522cdfd00e" class="code_img_closed" src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/ContractedBlock.gif" alt=""><img id="code_img_opened_47687689-81a9-47c5-8577-87522cdfd00e" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('47687689-81a9-47c5-8577-87522cdfd00e',event)" src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/ExpandedBlockStart.gif" alt="">
<div id="cnblogs_code_open_47687689-81a9-47c5-8577-87522cdfd00e" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">int</span> match(<span style="color: #0000ff;">char</span> c, <span style="color: #0000ff;">char</span><span style="color: #000000;"> d)
{
    </span><span style="color: #0000ff;">if</span> (c == d) <span style="color: #0000ff;">return</span>(<span style="color: #800080;">0</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span><span style="color: #000000;">(MAXLEN);
}</span></pre>
</div>
<span class="cnblogs_code_collapse">match()</span></div>
<p>　　此时，最小值是两者不同部分的距离。</p>
<p>　　（这部分同样也不好理解，对于最长公共子序列，建议直接使用下一部分中的解法）</p>
<p>&nbsp;</p>
<p>扩展：</p>
<p>　　如果在编辑距离中各个操作的代价不同，如何寻找最小代价？&nbsp;</p>
<h1><span style="font-size: 18pt;"><a name="q3"></a>3.最长公共子序列(Longest Common Subsequence,lcs)</span></h1>
<p><span style="font-size: 16px;">难度评级：★</span></p>
<p><span style="font-size: 16px;">　　对于序列S和T，求它们的最长公共子序列。例如X={A,B,C,B,D,A,B}，Y={B,D,C,A,B,A}则它们的lcs是{B,C,B,A}和{B,D,A,B}。求出一个即可。</span></p>
<p><span style="font-size: 16px;">解法：</span></p>
<p><span style="font-size: 16px;">　　和2类似，对于X[1...m]和Y[1...n]，它们的任意一个lcs是Z[1...k]。</span></p>
<p><span style="font-size: 16px;">　　(1)如果X[m]=Y[n]，那么Z[k]=<span>X[m]=Y[n],且</span><span>Z[1...k-1]是<span>X[1...m-1]和Y[1...n-1]的一个lcs；</span></span></span></p>
<p><span style="font-size: 16px;"><span><span>　　(2)<span>如果X[m]!=Y[n]，那么Z[k]!=</span><span>X[m]时</span><span>Z是X[1...m-1]和Y的一个lcs；</span></span></span></span></p>
<p><span style="font-size: 16px;"><span><span><span>　　(3)<span>如果X[m]!=Y[n]，那么Z[k]!=</span><span>Y[n]时</span><span>Z是X和Y[1...n-1]的一个lcs；</span></span></span></span></span></p>
<p><span style="font-size: 16px;"><span><span><span><span>　　下面是《算法导论》上用伪码描述的lcs算法。其中c[i][j]记录当前lcs长度，b[i][j]记录到达该状态的上一个状态。</span></span></span></span></span></p>
<p style="margin-left: 60px;"><span style="font-size: 16px;"><span><span><span><span><img src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/26112341-f895ed8c14f84d4c98e06588036538e2.jpg" alt=""></span></span></span></span></span></p>
<p style="margin-left: 60px;">&nbsp;</p>
<p><span style="font-size: 16px;"><span><span><span><span><a name="q3a1"></a>扩展1：</span></span></span></span></span></p>
<p><span style="font-size: 16px;"><span><span><span><span>　　如何输出所有的LCS？</span></span></span></span></span></p>
<p><span style="font-size: 16px;"><span><span><span><span><span>难度评级：★<span>★</span></span></span></span></span></span></span></p>
<p><span style="font-size: 16px;"><span><span><span><span>分析：</span></span></span></span></span></p>
<p><span style="font-size: 16px;"><span><span><span><span>　　根据上面c[i,j]和b[i,j]的构造过程可以发现如果c[i-1,j]==c[i,j-1]，那么分别向上和向左返回的上一个状态都是可行的。如果将其标记为“左/上”并通过递归调用来生成从c[m,n]到c[1,1]的所有路径，就能找出所有的LCS。时间复杂度上界为O(mn)。</span></span></span></span></span></p>
<p>&nbsp;</p>
<p><a name="q3a2"></a>扩展2：</p>
<p>　　通过LCS获得最长递增自子序列。</p>
<p>分析：</p>
<p>　　对于1个序列，如243517698，最大值9，最小值1，那么通过将它与123456789求LCS得到的就是最长连续递增子序列23568。</p>
<p>　　这种做法不适用于最长连续非递减子序列，除非能获得重复最多的元素数目，如2433517698，那么可以用112233445566778899与之比较。</p>
<p>　　使用专门的最长递增子序列算法可以进行优化，详见下一部分。</p>
<p>&nbsp;</p>
<h1><span style="font-size: 16px;"><span style="font-size: 18pt;"><a name="q4"></a>4.最长递增子序列（Longest Increasing Subsequence,lis）</span><br></span></h1>
<p><span>难度评级：★</span></p>
<p><span style="font-size: 16px;">&nbsp;　　对于一个序列如1，-1，2，-3，4，-5，6，-7，其最长第增子序列为1,2,4,6。</span></p>
<p><span style="font-size: 16px;">解法：</span></p>
<p><span style="font-size: 16px;">　　除了利用3中lcs来求解，这里使用求解lis问题的专门方法。</span></p>
<p><span style="font-size: 16px;">　　先看看如何确定<strong>子结构</strong>的表示。对于长度为k的序列s[1...k]，如果用lis[k]记录这个序列中最长子序列似乎没什么用，因为在构造lis[k+1]时，需要比较s[k]与前面长度为lis[k]的lis的最后一个元素、s[1...k]中长度为lis[k]-1的序列的最后一个元素等等，没有提供什么便利，这个方案被否决。</span></p>
<p><span style="font-size: 16px;">　　为了将每个lis[k]转化为构造lis[k+1]时有用的数据，把<strong>子结构</strong>记为以s[k]为结尾的lis的长度，那么对于s[k+1]，需要检查所有在它前面且小于它的元素s[i]，并令lis[k+1] = max(lis[i]+1),（i=1 to k,s[k+1]&gt;s[i]）。这样，一个O(n<sup>2</sup>)的算法便写成了。为了在处理完成后不必再一次遍历lis[1...n]，可以使用一个MaxLength变量保存当前记录中最长的lis。</span></p>
<p>&nbsp;</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/copycode.gif" alt="复制代码"></a></span></div>
<pre>typedef <span style="color: #0000ff;">struct</span><span style="color: #000000;"> {
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> length;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> prev;
} state;

</span><span style="color: #008000;">//</span><span style="color: #008000;">算法核心</span>
state *a = malloc(<span style="color: #0000ff;">sizeof</span>(state) *<span style="color: #000000;"> n);
</span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">0</span>;i&lt;n;i++<span style="color: #000000;">) {
    a[i].length </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
    a[i].prev </span>= -<span style="color: #800080;">1</span><span style="color: #000000;">;
}

</span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">1</span>;i&lt;n;i++<span style="color: #000000;">)
    </span><span style="color: #0000ff;">for</span>(j=<span style="color: #800080;">1</span>;j&lt;i;j++<span style="color: #000000;">)
        </span><span style="color: #0000ff;">if</span>(array[i]&gt;array[j] &amp;&amp; a[i].length &lt; a[j].length + <span style="color: #800080;">1</span><span style="color: #000000;">)
        {
            a[i].length </span>= a[j].length + <span style="color: #800080;">1</span><span style="color: #000000;">;
            a[i].prev </span>=<span style="color: #000000;"> j;
            </span><span style="color: #0000ff;">if</span>(a[i].length &gt;<span style="color: #000000;"> max_length) {
                max_length </span>=<span style="color: #000000;"> a[i].length;
                max_end </span>=<span style="color: #000000;"> i;
            }
        }</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><a name="q4a"></a>扩展：</p>
<p>　　求解lis的加速</p>
<p>&nbsp;<span>难度评级：★★</span></p>
<p><span style="font-size: 16px;">分析：</span></p>
<p><span style="font-size: 16px;">　　在构造lis[k+1]的时候可以发现，对于s[k+1]，真正有用的元素s[i]&lt;s[k+1]且lis[i]最大。如果记录了不同长度的lis的末尾元素，那么对于新加入的元素s[k+1]，找出前面比它小的且对应lis最长的，就是以s[k+1]为结尾的lis[k+1]的长度。</span></p>
<p><span style="font-size: 16px;">　　可以发现<span style="color: #339966;">使用数组MaxV[1...MAXLENGTH]其中MaxV[i]表示长度为i的lis的最小末尾元素</span>，完全可以在s[k+1]时进行lis[k+1]的更新。进一步地发现，其实lis[]数组已经没有用了，对于MaxV[1...MAXLENGTH]中值合法对应的最大下标，就是当前最长的lis，也即利用MaxV[]更新自身。</span></p>
<p><span style="font-size: 16px;">　　同时，根据<span>MaxV[]的更新过程，</span><span style="color: #339966;">可以得出当i&lt;j时，MaxV[i]&lt;MaxV[j]<span style="color: #000000;">（假设出现了i&gt;j且Max[i]=&gt;Max[j]的情况，那么在之前的处理中，在发现j长度的lis时，应用它的第i个元素来更新<span>Max[i]，仍会导致<span>MaxV[i]&lt;MaxV[j]，</span>这与这个现状发生了矛盾，也即这个情况是不可能到达的）。</span></span></span>这样，在<span>寻找小于</span>s[k+1]的值时，可以<span style="color: #339966;">使用二分查找，从而把时间复杂度降低至O(nlogn)</span>。</span></p>
<p>&nbsp;</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #0000ff;">int</span> lis_ologn(<span style="color: #0000ff;">int</span> *array, <span style="color: #0000ff;">int</span><span style="color: #000000;"> length) {
    </span><span style="color: #0000ff;">int</span> i, left,right,mid,max_len = <span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">int</span> *<span style="color: #000000;">MaxV;
    </span><span style="color: #0000ff;">if</span>(!<span style="color: #000000;">array)
        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
    MaxV </span>= (<span style="color: #0000ff;">int</span>*)malloc(<span style="color: #0000ff;">sizeof</span>(<span style="color: #0000ff;">int</span>)*(length+<span style="color: #800080;">1</span><span style="color: #000000;">));
    MaxV[</span><span style="color: #800080;">0</span>] = -<span style="color: #800080;">1</span><span style="color: #000000;">;
    MaxV[</span><span style="color: #800080;">1</span>] = array[<span style="color: #800080;">0</span><span style="color: #000000;">];

    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">1</span>;i&lt;length;i++<span style="color: #000000;">){
        </span><span style="color: #008000;">//</span><span style="color: #008000;">寻找范围是MaxV[1, ... , max_len]</span>
        left = <span style="color: #800080;">1</span><span style="color: #000000;">;
        right </span>=<span style="color: #000000;"> max_len;
        </span><span style="color: #008000;">//</span><span style="color: #008000;">二分查找MaxV中第一个大于array[i]的元素</span>
        <span style="color: #0000ff;">while</span>(left&lt;<span style="color: #000000;">right) {
            mid </span>= (left+right)/<span style="color: #800080;">2</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span>(MaxV[mid]&lt;=<span style="color: #000000;">array[i])
                left </span>= mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(MaxV[mid]&gt;<span style="color: #000000;">array[i])
                right </span>=<span style="color: #000000;"> mid;
        }
        </span><span style="color: #0000ff;">if</span>((MaxV[right]&gt;array[i])&amp;&amp;(MaxV[right-<span style="color: #800080;">1</span>]&lt;<span style="color: #000000;">array[i]))
            MaxV[right] </span>=<span style="color: #000000;"> array[i];
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (MaxV[right]&lt;<span style="color: #000000;">array[i]) {
            MaxV[right</span>+<span style="color: #800080;">1</span>] =<span style="color: #000000;"> array[i];
            max_len</span>++<span style="color: #000000;">;
        }
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> max_len;
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;　　在这个解法下，不妨考虑如何重构这个lis。</p>
<p>&nbsp;</p>
<h1><span style="font-size: 18pt;"><a name="q5"></a>5.最大连续子序列和/积</span></h1>
<p><span style="font-size: 16px;">难度评级：★</span></p>
<p><span style="font-size: 16px;">　　输入是具有n个数的向量x，输出时输入向量的任何连续子向量的最大和。</span></p>
<p><span style="font-size: 16px;">解法：</span></p>
<p><span style="font-size: 16px;">　　求和比较简单，以前写过比较全面的分析：<a href="http://www.cnblogs.com/wuyuegb2312/p/3139925.html#title4">http://www.cnblogs.com/wuyuegb2312/p/3139925.html#title4</a></span></p>
<p><span style="font-size: 16px;">　　这里只把O(n)的动态规划解法列在下面，其中只用一个变量保存过去的<strong>状态</strong>：</span></p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #0000ff;">int</span> max_array_v4(<span style="color: #0000ff;">int</span> *array,<span style="color: #0000ff;">int</span><span style="color: #000000;"> length) {
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i;
    </span><span style="color: #0000ff;">int</span> maxsofar =<span style="color: #000000;"> NI;
    </span><span style="color: #0000ff;">int</span> maxendinghere = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">0</span>;i&lt;length;i++<span style="color: #000000;">) {
        maxendinghere </span>= maxnum(maxendinghere +<span style="color: #000000;"> array[i],array[i]);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">分析：maxendinghere必须包含array[i]
        </span><span style="color: #008000;">//</span><span style="color: #008000;">当maxendinghere&gt;0且array[i]&gt;0，maxendinghere更新为两者和
        </span><span style="color: #008000;">//</span><span style="color: #008000;">当maxendinghere&gt;0且array[i]&lt;0，maxendinghere更新为两者和
        </span><span style="color: #008000;">//</span><span style="color: #008000;">当maxendinghere&lt;0且array[i]&lt;0，maxendinghere更新为array[i]
        </span><span style="color: #008000;">//</span><span style="color: #008000;">当maxendinghere&lt;0且array[i]&gt;0，maxendinghere更新为array[i]</span>
        maxsofar =<span style="color: #000000;"> maxnum(maxsofar,maxendinghere);
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> maxsofar;
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p><span style="font-size: 16px;"><a name="q5a1"></a>扩展1：</span></p>
<p><span style="font-size: 16px;">难度评级：★</span></p>
<p><span style="font-size: 16px;">　　给定一个<span style="text-decoration: underline;">正浮点数</span>数组，求它的一个最大<span style="line-height: 1.5;">连续</span><span style="line-height: 1.5;">子序列乘积的值。</span></span></p>
<p><span style="font-size: 16px;">解法：</span></p>
<p><span style="font-size: 16px;">　　对数组中每个元素取对数，构成新的数列，在新的数列上使用求最大连续子序列的算法。</span></p>
<p><span style="font-size: 16px;">　　如果求对数开销较大，建议使用扩展2的方法。</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 16px;"><a name="q5a2"></a>扩展2：</span></p>
<p><span style="font-size: 16px;">难度评级：★</span></p>
<p><span style="font-size: 16px;">　　给定一个<span style="text-decoration: underline;">浮点数</span>数组，其值<span style="text-decoration: underline;">可正可负可零</span>，求它的一个最大连续子序列乘积的值。（假定计算过程中，任意一个序列的积都不超过浮点数最大表示）</span></p>
<p><span style="font-size: 16px;">解法：</span></p>
<p><span style="font-size: 16px;">　　在最大连续子序列和算法的基础上进行修改。由于负负得正，对于当前状态array[k]，需要同时计算出它的最大值和最小值。即：</span></p>
<p><span style="font-size: 16px;">　　new_maxendinghere = max3(maxendinghere*array[k],minendinghere*array[k],array[k])</span></p>
<p><span style="font-size: 16px;">　　new_minendinghere = min3(maxendinghere*array[k],minendinghere*array[k],array[k])</span></p>
<p><span style="font-size: 16px;">　　此后对已遍历部分的最大积进行更新：</span></p>
<p><span style="font-size: 16px;">　　maxsofar = max(maxsofar,new_maxendinghere)</span></p>
<p><span style="font-size: 16px;">　　如果不习惯用常数个变量来表示，可以看看<a href="http://blog.csdn.net/wzy_1988/article/details/9319897">http://blog.csdn.net/wzy_1988/article/details/9319897</a>，再想想用数组保存是不是浪费了空间。（计算max[k]、min[k]只用到了max[k-1]、min[k-1]，没有必要保存全部状态）</span></p>
<p>&nbsp;</p>
<h1><span style="font-size: 18pt;"><a name="q6"></a>6.矩阵链乘法</span></h1>
<p><span style="font-size: 16px;">难度评级：★</span></p>
<p><span style="font-size: 16px;">　　一个给定的矩阵序列A<sub>1</sub>A<sub>2</sub>...A<sub>n</sub>计算连乘乘积，有不同的结合方法，<span>并且在结合时，矩阵的相对位置不能改变，只能相邻结合</span>。根据矩阵乘法的公式，10*100和100*5的矩阵相乘需要做10*100*5次标量乘法。那么对于维数分别为10*100、100*5、5*50的矩阵A、B、C，用(A*B)*C来计算需要10*100*5 + 10*5*500 =7500次标量乘法；而A*(B*C)则需要100*5*50+10*100*50=75000次标量乘法。</span></p>
<p><span style="font-size: 16px;">　　那么对于由n个矩阵构成的链&lt;A<sub>1</sub>,A<sub>2</sub>,...,A<sub>n</sub>&gt;，对i-1,2,...n，矩阵A<sub>i</sub>的维数为p<sub>i-1</sub>*p<sub>i</sub>，对乘积<span>A</span><sub>1</sub><span>A</span><sub>2</sub><span>...A</span><sub>n</sub>求出最小化标量乘法的加括号方案。</span></p>
<p><span style="font-size: 16px;">解法：</span></p>
<p><span style="font-size: 16px;">　　尽管可以通过递归计算取1&lt;=k&lt;n使得P(n)=∑P(k)P(n-k)，遍历所有P(n)种方案，但这并不是一个高效率的解法。</span></p>
<p><span style="font-size: 16px;">　　经过以上几道题的锻炼，很容易看出，子结构是求A<sub>i</sub>...A<sub>j</sub>的</span><span style="font-size: 16px; line-height: 24px;">加</span><span style="font-size: 16px; line-height: 1.5;">括号方法m[i][j]可递归地定义为</span></p>
<p>\[m[i][j]=\left\{\begin{matrix} 0&amp; if \ i=j\\ \underset{i\leqslant k&lt;j}{min}\begin{Bmatrix} m[i][k] + &amp; m[k+1][j] +&amp; p_{i-1}p_{k}p_{j} \end{Bmatrix} &amp; if \ i&lt;j \end{matrix}\right.\]</p>
<p><span style="font-size: 16px; line-height: 1.5;"><span>　　这样，只需利用子结构求解m[1][n]即可，并在在构造<span>m[1][n]的同时，记录状态转换。下面的代码展示了这个过程，不再仔细分析。</span></span></span></p>
<p>&nbsp;</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('11400358-dbb9-4e50-afb0-bc4ba790af8e')"><img id="code_img_closed_11400358-dbb9-4e50-afb0-bc4ba790af8e" class="code_img_closed" src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/ContractedBlock.gif" alt=""><img id="code_img_opened_11400358-dbb9-4e50-afb0-bc4ba790af8e" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('11400358-dbb9-4e50-afb0-bc4ba790af8e',event)" src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/ExpandedBlockStart.gif" alt="">
<div id="cnblogs_code_open_11400358-dbb9-4e50-afb0-bc4ba790af8e" class="cnblogs_code_hide">
<pre>#include &lt;stdio.h&gt;<span style="color: #000000;">
#include </span>&lt;stdlib.h&gt;
<span style="color: #0000ff;">#define</span> ULT    2147483647

<span style="color: #0000ff;">int</span> print_optimal_parens(<span style="color: #0000ff;">int</span> **s,<span style="color: #0000ff;">int</span> i, <span style="color: #0000ff;">int</span><span style="color: #000000;"> j)
{
    </span><span style="color: #0000ff;">if</span> (i==<span style="color: #000000;">j)
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">A%d</span><span style="color: #800000;">"</span>,i+<span style="color: #800080;">1</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">else</span><span style="color: #000000;">    {
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">(</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        print_optimal_parens(s,i,</span>*(*(s+i)+<span style="color: #000000;">j));
        print_optimal_parens(s,</span>*(*(s+i)+j)+<span style="color: #800080;">1</span><span style="color: #000000;">,j);
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">)</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
}



</span><span style="color: #0000ff;">int</span> matrix_chain_order(<span style="color: #0000ff;">int</span> *p, <span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i,j,k,l,q;
    </span><span style="color: #0000ff;">int</span> **m, **<span style="color: #000000;">s;
    m</span>=(<span style="color: #0000ff;">int</span> **)malloc(n*<span style="color: #0000ff;">sizeof</span>(<span style="color: #0000ff;">int</span>*<span style="color: #000000;">));
    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">0</span>;i&lt;n;i++<span style="color: #000000;">)
        m[i]</span>=(<span style="color: #0000ff;">int</span>*)malloc(n*<span style="color: #0000ff;">sizeof</span>(<span style="color: #0000ff;">int</span><span style="color: #000000;">));
    s</span>=(<span style="color: #0000ff;">int</span> **)malloc(n*<span style="color: #0000ff;">sizeof</span>(<span style="color: #0000ff;">int</span>*<span style="color: #000000;">));
    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">0</span>;i&lt;n;i++<span style="color: #000000;">)
        s[i]</span>=(<span style="color: #0000ff;">int</span>*)malloc(n*<span style="color: #0000ff;">sizeof</span>(<span style="color: #0000ff;">int</span><span style="color: #000000;">));

    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">0</span>;i&lt;n;i++<span style="color: #000000;">)
        s[i][i] </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008000;">//</span><span style="color: #008000;">m,s可以被压缩存储在上三角矩阵</span>

    <span style="color: #0000ff;">for</span>(l=<span style="color: #800080;">2</span>;l&lt;=n;l++<span style="color: #000000;">) {
        </span><span style="color: #0000ff;">for</span> (i=<span style="color: #800080;">0</span>;i&lt;n-l+<span style="color: #800080;">1</span>;i++<span style="color: #000000;">) {
            j </span>= i+l-<span style="color: #800080;">1</span><span style="color: #000000;">;
            m[i][j] </span>=<span style="color: #000000;"> ULT;
            </span><span style="color: #0000ff;">for</span> (k=i; k&lt;j;k++<span style="color: #000000;">)    {
                q </span>= m[i][k] + m[k+<span style="color: #800080;">1</span>][j] + p[i-<span style="color: #800080;">1</span>+<span style="color: #800080;">1</span>]*p[k+<span style="color: #800080;">1</span>]*p[j+<span style="color: #800080;">1</span><span style="color: #000000;">];
                </span><span style="color: #0000ff;">if</span> (q&lt;<span style="color: #000000;">m[i][j])        {
                    m[i][j] </span>=<span style="color: #000000;"> q;
                    s[i][j] </span>=<span style="color: #000000;"> k;
                }
            }
        }
    }

</span><span style="color: #008000;">/*</span><span style="color: #008000;">display m[i][j]</span><span style="color: #008000;">*/</span>
<span style="color: #008000;">//</span><span style="color: #008000;">    for (i=0;i&lt;n;i++) {
</span><span style="color: #008000;">//</span><span style="color: #008000;">        for (j=0;j&lt;n;j++)
</span><span style="color: #008000;">//</span><span style="color: #008000;">            printf("%d ",m[i][j]);
</span><span style="color: #008000;">//</span><span style="color: #008000;">        printf("\n");
</span><span style="color: #008000;">//</span><span style="color: #008000;">    }</span>
    print_optimal_parens(s,<span style="color: #800080;">0</span>,<span style="color: #800080;">5</span><span style="color: #000000;">);
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main() {
    </span><span style="color: #0000ff;">int</span> p[] = {<span style="color: #800080;">30</span>,<span style="color: #800080;">35</span>,<span style="color: #800080;">15</span>,<span style="color: #800080;">5</span>,<span style="color: #800080;">10</span>,<span style="color: #800080;">20</span>,<span style="color: #800080;">25</span><span style="color: #000000;">};
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n;
    n </span>= (<span style="color: #0000ff;">sizeof</span>(p)/<span style="color: #0000ff;">sizeof</span>(<span style="color: #0000ff;">int</span>))-<span style="color: #800080;">1</span><span style="color: #000000;">;
    matrix_chain_order(p,n);
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">矩阵链乘法</span></div>
<p>&nbsp;</p>
<p><a name="q6a"></a>扩展：</p>
<p>　　矩阵链乘法的备忘录解法（伪码），来自《算法导论》第15章。</p>
<p><img src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/11093154-c179276959d64f3cb802d6e390962f41.jpg" alt=""></p>
<p>&nbsp;</p>
<h1><span style="font-size: 18pt;"><a name="q7"></a>7.0-1背包</span></h1>
<p><span style="font-size: 16px;">难度评级：★★</span></p>
<p><span style="font-size: 16px;">　　一个贼在偷窃一家商店时发现了n件物品，其中第i件值v<sub>i</sub>元，重w<sub>i</sub>磅。他希望偷走的东西总和越值钱越好，但是他的背包只能放下W磅。请求解如何放能偷走最大价值的物品，这里<span>v</span><sub>i</sub><span>、w</span><sub>i</sub>、W都是整数。</span></p>
<p><span style="font-size: 16px;">解法：</span></p>
<p><span style="font-size: 16px;">　　如果每个物品都允许切割并只带走其一部分，则演变为部分背包问题，可以用贪心法求解。<span>0-1背包问题经常作为贪心法不可解决的实例（可通过举反例来理解），但可以通过动态规划求解。</span></span></p>
<p><span style="font-size: 16px;"><span>　　为了找出子结构的形式，粗略地分析发现，对前k件物品形成最优解时，需要决策第k+1件是否要装入背包。但是此时剩余容量未知，不能做出决策。因此把剩余容量也考虑进来，形成的<strong>状态</strong>由已决策的物品数目和剩余容量两者构成。这样，所有状态可以放入一个n*(W+1)的矩阵c中，其值为当前包中物品总价值，这时有</span></span></p>
<p>\[c[i][j]=\left\{\begin{matrix} c[i-1][j]&amp; if \ w_{i}&gt;j\\ \max\begin{Bmatrix} c[i-1][j-w_{i}]+v_{i} \ ,\ c[i-1][j] \end{Bmatrix} &amp; if \ w_{i}\leqslant j \end{matrix}\right.\]</p>
<p><span style="font-size: 16px;">　　根据这个递推公式，很容易写出求解代码。</span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('3860dfc4-fd57-458f-9278-436f708471b1')"><img id="code_img_closed_3860dfc4-fd57-458f-9278-436f708471b1" class="code_img_closed" src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/ContractedBlock.gif" alt=""><img id="code_img_opened_3860dfc4-fd57-458f-9278-436f708471b1" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('3860dfc4-fd57-458f-9278-436f708471b1',event)" src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/ExpandedBlockStart.gif" alt="">
<div id="cnblogs_code_open_3860dfc4-fd57-458f-9278-436f708471b1" class="cnblogs_code_hide">
<pre>#include &lt;stdio.h&gt;<span style="color: #000000;">
#include </span>&lt;stdlib.h&gt;

<span style="color: #0000ff;">int</span> package_dp(<span style="color: #0000ff;">int</span> *v,<span style="color: #0000ff;">int</span> *w,<span style="color: #0000ff;">int</span> n,<span style="color: #0000ff;">int</span><span style="color: #000000;"> total) {
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i,j,tmp1,tmp2;
    </span><span style="color: #0000ff;">int</span> **c = (<span style="color: #0000ff;">int</span> **)malloc((n+<span style="color: #800080;">1</span>)*<span style="color: #0000ff;">sizeof</span>(<span style="color: #0000ff;">int</span> *<span style="color: #000000;">));
    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">0</span>;i&lt;n+<span style="color: #800080;">1</span>;i++<span style="color: #000000;">)
        c[i]</span>=(<span style="color: #0000ff;">int</span> *)malloc((total+<span style="color: #800080;">1</span>)*<span style="color: #0000ff;">sizeof</span>(<span style="color: #0000ff;">int</span><span style="color: #000000;">));
    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">0</span>,j=<span style="color: #800080;">0</span>;j&lt;total;j++<span style="color: #000000;">)
        c[i][j] </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">) {
        c[i][</span><span style="color: #800080;">0</span>] = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span>(j=<span style="color: #800080;">1</span>;j&lt;=total;j++<span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span>(w[i]&gt;<span style="color: #000000;">j)
                c[i][j] </span>= c[i-<span style="color: #800080;">1</span><span style="color: #000000;">][j];
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                tmp1 </span>= v[i]+c[i-<span style="color: #800080;">1</span>][j-<span style="color: #000000;">w[i]];
                tmp2 </span>= c[i-<span style="color: #800080;">1</span><span style="color: #000000;">][j];
                c[i][j]</span>=(tmp1&gt;tmp2?<span style="color: #000000;">tmp1:tmp2);
            }
        }
    }
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">c[%d][%d]:%d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,n,total,c[n][total]);
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main() {
    </span><span style="color: #0000ff;">int</span> v[] = {<span style="color: #800080;">0</span>,<span style="color: #800080;">10</span>,<span style="color: #800080;">25</span>,<span style="color: #800080;">40</span>,<span style="color: #800080;">20</span>,<span style="color: #800080;">10</span><span style="color: #000000;">};
    </span><span style="color: #0000ff;">int</span> w[] = {<span style="color: #800080;">0</span>,<span style="color: #800080;">40</span>,<span style="color: #800080;">50</span>,<span style="color: #800080;">70</span>,<span style="color: #800080;">40</span>,<span style="color: #800080;">20</span><span style="color: #000000;">};
    </span><span style="color: #0000ff;">int</span> total = <span style="color: #800080;">120</span><span style="color: #000000;">;
    package_dp(v,w,</span><span style="color: #0000ff;">sizeof</span>(v)/<span style="color: #0000ff;">sizeof</span>(<span style="color: #0000ff;">int</span>)-<span style="color: #800080;">1</span><span style="color: #000000;">,total);
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">0-1背包问题示例代码</span></div>
<p>&nbsp;</p>
<h1><span style="font-size: 18pt;"><a name="q8"></a>8.有代价的最短路径</span></h1>
<p><span style="font-size: 16px;">难度评级：★★<span>★</span></span></p>
<p><span style="font-size: 16px;">　　无向图G中有N个顶点，并通过一些边相连接，边的权值均为正数。初始时你身上有M元，当走过i点时，需要支付S(i)元，如果支付不起表示不能通过。请找出顶点1到顶点N的最短路径。如果不存在则返回一个特殊值，如果存在多条则返回最廉价的一条。限制条件：1&lt;N&lt;=100; 0&lt;=M&lt;=100 ; 对任意i, 0&lt;=S[i]&lt;=100。</span></p>
<p><span style="font-size: 16px;">解法：</span></p>
<p><span style="font-size: 16px;">　　如果不考虑经过顶点时的花费，这就简化成了一个一般的两点间最短路径问题，可以用Dijkstra算法求解。加入了花费限制之后，就不能直接求解了。</span></p>
<p><span style="font-size: 16px;">　　考察从顶点0到达顶点i的不同状态，会发现它们之间的区别是：总花费相同但路径长度不同、总花费不同但路径长度不同。为了寻找最短路径，必然要保存到达i点的最短路径；同时为了找到最小开销，应该把到达i点的开销也进行保存。根据题目的数值限制，可以将总开销作为到达顶点i的一个状态区分。这样，就可以把Min[i][j]表示为到达顶点i（并经过付钱）时还剩余j元钱的最短路径的长度。在此基础上修改Dijkstra算法，使其能够保存到达同一点不同花费时的最短长度，最终的Min[N-1][0...M]中最小的即为所求。以下是求解过程的伪代码。</span></p>
<p><span style="font-size: 16px;">　　</span></p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008000;">//</span><span style="color: #008000;">初始化</span>
对所有的(i,j),Min[i][j] = ∞,state[i][j] =<span style="color: #000000;"> unvisited;
Min[</span><span style="color: #800080;">0</span>][M] = <span style="color: #800080;">0</span><span style="color: #000000;">;

</span><span style="color: #0000ff;">while</span>(<span style="color: #800080;">1</span><span style="color: #000000;">) {
    </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> 所有unvisited的(i,j)找出M[i][j]最小的，记为(k,l)
    </span><span style="color: #0000ff;">if</span> Min[k][l] =<span style="color: #000000;"> ∞
        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;

    state[k][l] </span>=<span style="color: #000000;"> visited;
    </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> 所有顶点k的邻接点p
        </span><span style="color: #0000ff;">if</span> (l-S[p]&gt;=<span style="color: #800080;">0</span> &amp;&amp; Min[p][<span style="color: #800080;">1</span>-S[p]]&gt;Min[k][l]+<span style="color: #000000;">Dist[k][p])
            Min[p][</span><span style="color: #800080;">1</span>-S[p]] = Min[k][l]+<span style="color: #000000;">Dist[k][p];

    </span><span style="color: #008000;">//</span><span style="color: #008000;">通过Dijstra算法寻找不同花费下的最小路径</span>
<span style="color: #000000;">}

</span><span style="color: #0000ff;">for</span> 所有j，找出Min[N-<span style="color: #800080;">1</span><span style="color: #000000;">][j]最小的
    如果存在多个j，那么选出其中j最大的</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1><span style="font-size: 18pt; line-height: 1.5;"><a name="q9"></a>9.瓷砖覆盖（状态压缩DP）</span></h1>
<p><span style="font-size: 16px; line-height: 1.5;"><span>难度评级：★★</span><span>★</span></span></p>
<p><span style="font-size: 16px; line-height: 1.5;">　　</span><span style="font-size: 16px;">用 1 * 2 的瓷砖覆盖 n * m 的地板，问共有多少种覆盖方式？</span></p>
<p><span style="font-size: 16px;">&nbsp;解法：</span></p>
<p><span style="font-size: 16px;">　　（启发来自于：<a href="http://blog.csdn.net/limchiang/article/details/8619611">poj 2411 &amp; 编程之美 4.2 瓷砖覆盖地板</a>，下文叙述做了点修改）</span></p>
<p><span style="font-size: 16px;">　　分析<strong>子结构</strong>，按行铺瓷砖。一块1*2瓷砖，横着放对下一行的状态没有影响；竖着放时，下一行的对应一格就会被占用。因此，考虑第i行的铺法时只需考虑由第i-1行造成的条件限制。枚举枚举第i-1行状态即可获得i行可能的状态，这里为了与链接一文一致，第i-1行的某格只有两个状态：空或者放置。空表示第i行对应位置需要放置一个竖着的瓷砖，这时在铺第i行时，除去限制以外，只需考虑放还是不放横着的瓷砖这2种情况即可（不必分为放还是不放、横到下一层还是竖着一共4种）。同时对于第i-1行的放法，用二进制中0和1表示有无瓷砖，那么按位取反恰好就是第i行的限制条件。</span></p>
<p>&nbsp;</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008000;">//</span><span style="color: #008000;">原作者：limchiang
</span><span style="color: #008000;">//</span><span style="color: #008000;">出处：</span><span style="color: #008000; text-decoration: underline;">http://blog.csdn.net/limchiang/article/details/8619611</span>
#include &lt;stdio.h&gt;<span style="color: #000000;">
#include </span>&lt;<span style="color: #0000ff;">string</span>.h&gt;

<span style="color: #008000;">/*</span><span style="color: #008000;">* n * m 的地板 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">int</span><span style="color: #000000;"> n,m;

</span><span style="color: #008000;">/*</span><span style="color: #008000;">* dp[i][j] = x 表示使第i 行状态为j 的方法总数为x </span><span style="color: #008000;">*/</span><span style="color: #000000;">
__int64 dp[</span><span style="color: #800080;">12</span>][<span style="color: #800080;">2049</span><span style="color: #000000;">];

</span><span style="color: #008000;">/*</span><span style="color: #008000;"> 该方法用于搜索某一行的横向放置瓷砖的状态数,并把这些状态累加上row-1 行的出发状态的方法数
 * @name row 行数 
 * @name state 由上一行决定的这一行必须放置竖向瓷砖的地方，s的二进制表示中的1 就是这些地方
 * @name pos 列数
 * @name pre_num row-1 行的出发状态为~s 的方法数
 </span><span style="color: #008000;">*/</span> 
<span style="color: #0000ff;">void</span> dfs( <span style="color: #0000ff;">int</span> row, <span style="color: #0000ff;">int</span> state, <span style="color: #0000ff;">int</span><span style="color: #000000;"> pos, __int64 pre_num )
{
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* 到最后一列  </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">if</span>( pos ==<span style="color: #000000;"> m ){
        dp[row][state] </span>+=<span style="color: #000000;"> pre_num;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
    }

    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* 该列不放 </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    dfs( row, state, pos </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">, pre_num );

    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* 该列和下一列放置一块横向的瓷砖 </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">if</span>( ( pos &lt;= m-<span style="color: #800080;">2</span> ) &amp;&amp; !( state &amp; ( <span style="color: #800080;">1</span> &lt;&lt; pos ) ) &amp;&amp; !( state &amp; ( <span style="color: #800080;">1</span> &lt;&lt; ( pos + <span style="color: #800080;">1</span><span style="color: #000000;"> ) ) ) )
        dfs( row, state </span>| ( <span style="color: #800080;">1</span> &lt;&lt; pos ) | ( <span style="color: #800080;">1</span> &lt;&lt; ( pos + <span style="color: #800080;">1</span> ) ), pos + <span style="color: #800080;">2</span><span style="color: #000000;">, pre_num );
}
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{    
    </span><span style="color: #0000ff;">while</span>( scanf(<span style="color: #800000;">"</span><span style="color: #800000;">%d%d</span><span style="color: #800000;">"</span>,&amp;n,&amp;m) &amp;&amp; ( n ||<span style="color: #000000;"> m ) ){
        </span><span style="color: #008000;">/*</span><span style="color: #008000;">* 对较小的数进行状压，已提高效率 </span><span style="color: #008000;">*/</span>
        <span style="color: #0000ff;">if</span>( n &lt;<span style="color: #000000;"> m ){
            n</span>=n^<span style="color: #000000;">m;
            m</span>=n^<span style="color: #000000;">m;
            n</span>=n^<span style="color: #000000;">m;
        }

        memset( dp, </span><span style="color: #800080;">0</span>, <span style="color: #0000ff;">sizeof</span><span style="color: #000000;">( dp ) );

        </span><span style="color: #008000;">/*</span><span style="color: #008000;">* 初始化第一行 </span><span style="color: #008000;">*/</span><span style="color: #000000;">
        dfs( </span><span style="color: #800080;">1</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">1</span><span style="color: #000000;"> );

        </span><span style="color: #0000ff;">for</span>( <span style="color: #0000ff;">int</span> i = <span style="color: #800080;">2</span>; i &lt;= n; i ++<span style="color: #000000;"> ) 
            </span><span style="color: #0000ff;">for</span>( <span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; ( <span style="color: #800080;">1</span> &lt;&lt; m ); j ++<span style="color: #000000;"> ){
                </span><span style="color: #0000ff;">if</span>( dp[i-<span style="color: #800080;">1</span><span style="color: #000000;">][j] ){
                    __int64 tmp </span>= dp[i-<span style="color: #800080;">1</span><span style="color: #000000;">][j];

                    </span><span style="color: #008000;">/*</span><span style="color: #008000;"> 如果i-1行的出发状态某处未放，必然要在i行放一个竖的方块，
                     * 所以我对上一行状态按位取反之后的状态就是放置了竖方块的状态
                     </span><span style="color: #008000;">*/</span><span style="color: #000000;">
                    dfs( i, ( </span>~j ) &amp; ( ( <span style="color: #800080;">1</span> &lt;&lt; m ) - <span style="color: #800080;">1</span> ), <span style="color: #800080;">0</span><span style="color: #000000;">, tmp ) ;
                }
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">continue</span><span style="color: #000000;">;        
            }

        </span><span style="color: #008000;">/*</span><span style="color: #008000;">* 注意并不是循环i 输出 dp[n][i]中的最大值 </span><span style="color: #008000;">*/</span><span style="color: #000000;">
        printf( </span><span style="color: #800000;">"</span><span style="color: #800000;">%I64d\n</span><span style="color: #800000;">"</span>,dp[n][(<span style="color: #800080;">1</span>&lt;&lt;m)-<span style="color: #800080;">1</span><span style="color: #000000;">] ); 

    }
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1><span style="font-size: 18pt;"><a name="q10"></a>10.工作量划分</span></h1>
<p><span style="font-size: 16px;"><span>难度评级：★★</span></span></p>
<p><span style="font-size: 16px;">　　假设书架上一共有9本书，每本书各有一定的页数，分配3个人来进行阅读。为了便于管理，分配时，各书要求保持连续，比如第1、2、3本书分配给第1人，4、5分配给第二人，6，7，8，9分配给第3人，但不能1，4，2分配给第1人，3，5，6分配给第2人。即用两个隔板插入8个空隙中将9本书分成3部分，书不能换位。同时，分配时必须整本分配，同一本书不能拆成两部分分给两个人。为了公平起见，需要将工作量最大的那一部分最小化，请设计分配方案。用s<sub>1</sub>,...,s<sub>n</sub>表示各本书的页数。</span></p>
<p><span style="font-size: 16px;">解法：</span></p>
<p><span style="font-size: 16px;">　　继续从<strong>子结构</strong>的角度出发，发现如果前面的k-1份已经分好了，那么第k份自然也就分好了。用M[n][k]表示将n本书分成k份时最小化的k份中的最大工作量，从第k份也就是最后一份的角度来看，总数-它的不同情况下数量 = 前k-1份的数量和。</span></p>
<p>\[M[n][k] = \overset{n}{\underset{i=1}{min}}\max(M[i][k-1],\sum_{j=i+1}^{n}s_{j})\]</p>
<p>&nbsp;　　除此以外，初始化为</p>
<p>\[M[1][k] = s_{1},for \ all \ k&gt;0\\ M[n][1] = \sum_{i=1}^{n}s_{1}\]</p>
<p><span style="font-size: 16px;">　　自底向上地可以求得使M[n][k]最小化的解。</span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('d749ea0d-b47c-454c-a075-3ebeaf3b328e')"><img id="code_img_closed_d749ea0d-b47c-454c-a075-3ebeaf3b328e" class="code_img_closed" src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/ContractedBlock.gif" alt=""><img id="code_img_opened_d749ea0d-b47c-454c-a075-3ebeaf3b328e" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('d749ea0d-b47c-454c-a075-3ebeaf3b328e',event)" src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/ExpandedBlockStart.gif" alt="">
<div id="cnblogs_code_open_d749ea0d-b47c-454c-a075-3ebeaf3b328e" class="cnblogs_code_hide">
<pre>#include &lt;stdio.h&gt;
<span style="color: #0000ff;">#define</span> MAXN 9
<span style="color: #0000ff;">#define</span> MAXINT 32767

<span style="color: #0000ff;">void</span> print_books(<span style="color: #0000ff;">int</span> s[],<span style="color: #0000ff;">int</span> start,<span style="color: #0000ff;">int</span><span style="color: #000000;"> end);
</span><span style="color: #0000ff;">int</span> reconstruct_partition(<span style="color: #0000ff;">int</span> s[],<span style="color: #0000ff;">int</span> d[MAXN+<span style="color: #800080;">1</span>][MAXN+<span style="color: #800080;">1</span>],<span style="color: #0000ff;">int</span> n,<span style="color: #0000ff;">int</span><span style="color: #000000;"> k);
</span><span style="color: #0000ff;">int</span> max(<span style="color: #0000ff;">int</span> a,<span style="color: #0000ff;">int</span><span style="color: #000000;"> b);

</span><span style="color: #0000ff;">int</span> max(<span style="color: #0000ff;">int</span> a,<span style="color: #0000ff;">int</span><span style="color: #000000;"> b)
{
    </span><span style="color: #0000ff;">if</span>(a&gt;<span style="color: #000000;">b)
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> a;
    </span><span style="color: #0000ff;">else</span>
        <span style="color: #0000ff;">return</span><span style="color: #000000;"> b;
}

</span><span style="color: #0000ff;">int</span> partition(<span style="color: #0000ff;">int</span> s[],<span style="color: #0000ff;">int</span> n,<span style="color: #0000ff;">int</span><span style="color: #000000;"> k)
{
    </span><span style="color: #0000ff;">int</span> m[MAXN+<span style="color: #800080;">1</span>][MAXN+<span style="color: #800080;">1</span><span style="color: #000000;">];
    </span><span style="color: #0000ff;">int</span> d[MAXN+<span style="color: #800080;">1</span>][MAXN+<span style="color: #800080;">1</span><span style="color: #000000;">];
    </span><span style="color: #0000ff;">int</span> p[MAXN+<span style="color: #800080;">1</span><span style="color: #000000;">];
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> cost;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i,j,x;

    p[</span><span style="color: #800080;">0</span>] = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">)
        p[i] </span>= p[i-<span style="color: #800080;">1</span>]+s[i-<span style="color: #800080;">1</span><span style="color: #000000;">];
    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">)
        m[i][</span><span style="color: #800080;">1</span>] =<span style="color: #000000;"> p[i];
    </span><span style="color: #0000ff;">for</span>(j=<span style="color: #800080;">1</span>;j&lt;=k;j++<span style="color: #000000;">)
        m[</span><span style="color: #800080;">1</span>][j] = s[<span style="color: #800080;">0</span><span style="color: #000000;">];
    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">2</span>;i&lt;=n;i++<span style="color: #000000;">)
        </span><span style="color: #0000ff;">for</span>(j=<span style="color: #800080;">2</span>;j&lt;=k;j++<span style="color: #000000;">)
        {
            m[i][j] </span>=<span style="color: #000000;"> MAXINT;
            </span><span style="color: #0000ff;">for</span>(x=<span style="color: #800080;">1</span>;x&lt;=(i-<span style="color: #800080;">1</span>);x++<span style="color: #000000;">) 
            {
                cost </span>= max(m[x][j-<span style="color: #800080;">1</span>],p[i]-<span style="color: #000000;">p[x]);
                </span><span style="color: #0000ff;">if</span>(m[i][j]&gt;<span style="color: #000000;">cost) {
                    m[i][j] </span>=<span style="color: #000000;"> cost;
                    d[i][j] </span>=<span style="color: #000000;"> x;
                }
            }
        }
    reconstruct_partition(s,d,n,k);
}

</span><span style="color: #0000ff;">int</span> reconstruct_partition(<span style="color: #0000ff;">int</span> s[],<span style="color: #0000ff;">int</span> d[MAXN+<span style="color: #800080;">1</span>][MAXN+<span style="color: #800080;">1</span>],<span style="color: #0000ff;">int</span> n,<span style="color: #0000ff;">int</span><span style="color: #000000;"> k)
{
    </span><span style="color: #0000ff;">if</span>(k==<span style="color: #800080;">1</span><span style="color: #000000;">)
        print_books(s,</span><span style="color: #800080;">1</span><span style="color: #000000;">,n);
    </span><span style="color: #0000ff;">else</span><span style="color: #000000;">
    {
        reconstruct_partition(s,d,d[n][k],k</span>-<span style="color: #800080;">1</span><span style="color: #000000;">);
        print_books(s,d[n][k]</span>+<span style="color: #800080;">1</span><span style="color: #000000;">,n);
    }
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}

</span><span style="color: #0000ff;">void</span> print_books(<span style="color: #0000ff;">int</span> s[],<span style="color: #0000ff;">int</span> start,<span style="color: #0000ff;">int</span><span style="color: #000000;"> end)
{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i;
    </span><span style="color: #0000ff;">for</span>(i=start;i&lt;=end;i++<span style="color: #000000;">)
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;"> %d </span><span style="color: #800000;">"</span>,s[i-<span style="color: #800080;">1</span><span style="color: #000000;">]);
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main() {
    </span><span style="color: #0000ff;">int</span> a[] = {<span style="color: #800080;">1</span>,<span style="color: #800080;">1</span>,<span style="color: #800080;">1</span>,<span style="color: #800080;">1</span>,<span style="color: #800080;">1</span>,<span style="color: #800080;">1</span>,<span style="color: #800080;">1</span>,<span style="color: #800080;">1</span>,<span style="color: #800080;">1</span><span style="color: #000000;">};
    </span><span style="color: #0000ff;">int</span> b[] = {<span style="color: #800080;">1</span>,<span style="color: #800080;">2</span>,<span style="color: #800080;">3</span>,<span style="color: #800080;">4</span>,<span style="color: #800080;">5</span>,<span style="color: #800080;">6</span>,<span style="color: #800080;">7</span>,<span style="color: #800080;">8</span>,<span style="color: #800080;">9</span><span style="color: #000000;">};
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">first:\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    partition(a,</span><span style="color: #800080;">9</span>,<span style="color: #800080;">3</span><span style="color: #000000;">);
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">\nsecond:\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    partition(b,</span><span style="color: #800080;">9</span>,<span style="color: #800080;">3</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">工作量划分</span></div>
<p>&nbsp;</p>
<p><span style="font-size: 16px;">其他：</span></p>
<p><span style="font-size: 16px;">　　这个问题被称为线性分割(linear partition)问题，有不少的应用情形。如，一系列任务分配给几个并行进程，那么分配工作量最大任务的那个进程将成为影响最终完成时间的瓶颈。将最大的工作量尽量减少，能够使所有工作更快地完成。</span></p>
<p>&nbsp;</p>
<h1><span style="font-size: 18pt;"><a name="q11"></a>11.三次捡苹果</span></h1>
<p><span style="font-size: 16px;"><span>难度评级：★★</span><span>★</span></span></p>
<p><span style="font-size: 16px;">　　（问题1的相关问题(1)的进一步扩展）<span>一个矩形区域被划分为N*M个小矩形格子，在格子(i,j)中有A[i][j]个苹果。现在从左上角的格子(1,1)出发，要求每次只能向右走一步或向下走一步，每经过一个格子就把其中的苹果全部拿走<span>，最后到达(N,M)</span>。此时，只允许向上或向左走一步，反方向<span>走回(1,1)。这一趟可以不走第一趟的路线，但当经过第一趟所经过的格子时，里面已经没有苹果了。到达(1,1)后，再次反方向地只允许向右或向下走，走到(N,M)，同样可以不走前两趟走过的路线。求这三趟的走法，使得最终能拿取最多数量的苹果。</span></span></span></p>
<p><span style="font-size: 16px;"><span><span>解法：</span></span></span></p>
<p><span style="font-size: 16px;"><span><span>　　这个问题有两个难点，首先要理清三条路线的关系。可以发现，虽然第二趟方向相反，但其实和从(1,1)走到(N,M)是一样的，即三趟路线全部可以转化为从(1,1)向下或向右走到(N,M)的过程。<br>　　观察三条路线可以发现，实际中走的时候如果路线有交叉，可以把这种情况转化为相遇而不交错的情况如下图：<br></span></span></span></p>
<p><span style="font-size: 16px;"><span><span><img src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/27145720-c8b379109d40404f95cfd04761773909.png" alt=""></span></span></span></p>
<p>这样做的好处是，对于红线和蓝线上同一行j的点的坐标(i,j)(i',j)，总有i&lt;=i',这样就能够把三条路线划分成左、中、右三条有序的路线。</p>
<p>　　经过两次转化，可以构造<strong>子结构</strong>了。用Max[y-1][i][j][k]表示在y-1行时，三条路线分别在i、j、k时所能取得的最大苹果数，用Max[y-1][i][j][k]可以求解任意的Max[y][i'][j'][k']，其中i' = i to j' , j' = j to k', k' = k to M. 如果线路重叠，苹果已经被取走，不用重复考虑。因此处理每一行时为了简单起见最好维护一个该位置苹果是否被取走的标志位，方便在路线重叠时计算。根据上面的范围关系，先求k'的所有情况，然后是j'，最后才是i'。这样Max[N][M][M][M]就是三趟后所能取得的最多苹果数。</p>
<p>&nbsp;</p>
<p><a name="ref"></a>参考资料</p>
<p style="margin-left: 30px;">《算法导论》第15章动态规划、第16章贪心算法</p>
<p style="margin-left: 30px;">《算法设计手册》第八章动态规划</p>
<p style="margin-left: 30px;">《编程珠玑》相关问题</p>
<p style="margin-left: 30px;">《编程之美》相关问题</p>
<p style="margin-left: 30px;"><a href="http://blog.csdn.net/limchiang/article/details/8619611">poj 2411 &amp; 编程之美 4.2 瓷砖覆盖地板</a></p>
<p style="margin-left: 30px;"><a href="http://blog.csdn.net/wzy_1988/article/details/9319897">最大连续子序列乘积</a></p>
<p style="margin-left: 30px;"><a href="http://community.topcoder.com/tc?module=Static&amp;d1=tutorials&amp;d2=dynProg" target="_blank"><span>Dynamic Programming: From novice to advanced</span></a></p>
<p>&nbsp;</p>
<h1><span style="font-size: 18pt;"><a name="a1"></a>附录1：其他的一些动态规划问题与解答（链接）</span></h1>
<p><a href="http://www.cppblog.com/doer-xee/archive/2009/11/30/102296.html" target="_blank">双调欧几里德旅行商问题（算法导论思考题15-1）</a></p>
<p>&nbsp;　　评：网络上的很多中文版本，都不如直接看这篇文章里的英文原版解答理解的清楚。</p>
<p>&nbsp;</p>
<p><a href="http://blog.csdn.net/wenlei_zhouwl/article/details/5992367" target="_blank">整齐打印（算法导论思考题15-4）</a></p>
<p>　　评：难度不高，注意要求的是空格数的立方和最小。</p>
<p>&nbsp;</p>
<p><a href="http://zh.wikipedia.org/zh/%E7%BB%B4%E7%89%B9%E6%AF%94%E7%AE%97%E6%B3%95" target="_blank">动态规划应用：Viterbi算法</a></p>
<p>　　评：需要一些马尔科夫链的知识。理解起来不是很容易，理解以后是不是有种像是更多个生产线的装备线调度？</p>
<p>&nbsp;</p>
<p><a href="http://www.cnblogs.com/longdouhzt/archive/2011/07/27/2117978.html" target="_blank">最高效益的调度（算法导论思考题15-7）</a></p>
<p>　　评：和0-1背包问题何其相似。</p>
<p>&nbsp;</p>
<h1><span style="font-size: 18pt;"><a name="a2"></a>附录2：《算法设计手册》第八章 动态规划 面试题解答</span></h1>
<p>8-24.</p>
<p>　　给定一个硬币种类的集合，找出凑出给定一个值所用的最小硬币数目。</p>
<p>解答：</p>
<p>　　正文问题1已做解答，略。</p>
<p>&nbsp;</p>
<p>8-25.</p>
<p>　　长度为n的数组，其中元素可正可负可零。找出数组索引i,j使得从i到j的元素之和最大。</p>
<p>解答：</p>
<p>　　最大连续自序列和问题，请参考正文问题5的解答。</p>
<p>&nbsp;</p>
<p>8-26.</p>
<p>　　假设你有一页纸，正面和背面都写满了字母，当剪掉正面上一个字母时，这一页的背面的字母也会被剪掉。设计一个算法来验证是否能通过这张纸生成一个给定的字符串？提供一个函数，当你输入一个字母的位置时能够返回它背面的字母。（叙述关键思路即可）</p>
<p>解答：</p>
<p>　　目前我所看到的最容易理解的解法是使用最大流来解的：<a href="http://stackoverflow.com/questions/6135443/dynamic-programming-question">http://stackoverflow.com/questions/6135443/dynamic-programming-question</a></p>
<p>　　下面把思路大意翻译一下。</p>
<p>　　假设需要拼成的字符串是"FOO"，同时这张纸的正反面对应位置上的内容（可以通过提供的函数获得）分别是：</p>
<table style="height: 63px; width: 257px;" border="0">
<tbody>
<tr>
<td><span style="font-size: 16px;">位置</span></td>
<td><span style="font-size: 16px;">1</span></td>
<td><span style="font-size: 16px;">2</span></td>
<td><span style="font-size: 16px;">3</span></td>
<td><span style="font-size: 16px;">4</span></td>














</tr>
<tr>
<td><span style="font-size: 16px;">正面</span></td>
<td>F</td>
<td>C</td>
<td>O</td>
<td>Z</td>














</tr>
<tr>
<td><span style="font-size: 16px;">反面</span></td>
<td>O</td>
<td>O</td>
<td>K</td>
<td>Z</td>














</tr>














</tbody>














</table>
<p>　　由于位置4上的字母的正反面都用不到，忽略。</p>
<p>　　把这个表格转化成一个两层结点的流量网络</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/27154012-1e093af38b494c79b6cbec361006bba8.png" alt="" height="285" width="183"></p>
<p>　　其中源点下面第一层表示拼成所需字符串的所有字母，源点到达该点的流量是需要的数目。第一层与第二层相连接表示某一位置上对应的是哪个所需字母，比如位置1正反面分别是F和O，表示它能提供1个F的入度和1个O的入度，但又由于一个片纸无论正反面只能用一次，那么它只能提供1的出度，直接连接汇点。</p>
<p>　　这个问题是否有解，等价于这个流量网络中是否存在一个流使得源点的流的出度等于汇点流的的入度，即一个最大流问题。</p></div><div style="display: block;" id="MySignature"><div id="AllanboltSignature">
        <p id="PSignature" style="border-top: #e0e0e0 1px dashed; border-right: #e0e0e0 1px dashed; border-bottom: #e0e0e0 1px dashed; border-left: #e0e0e0 1px dashed;
            padding-top: 10px;padding-right: 10px;padding-bottom: 10px;padding-left: 60px;
            font-family: 微软雅黑; font-size:11px;">
            <br>
            作者：<a href="http://www.cnblogs.com/wuyuegb2312" target="_blank">五岳</a>
            <br>
            出处：<a href="http://www.cnblogs.com/wuyuegb2312" target="_blank">http://www.cnblogs.com/wuyuegb2312</a>
            <br>
            对于标题未标注为“转载”的文章均为原创，其版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。
        </p>
    　</div></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory">分类: <a href="http://www.cnblogs.com/wuyuegb2312/category/476925.html">笔试面试题</a>, <a href="http://www.cnblogs.com/wuyuegb2312/category/416678.html">算法</a></div>
<div id="EntryTag">标签: <a href="http://www.cnblogs.com/wuyuegb2312/tag/%E7%AE%97%E6%B3%95/">算法</a>, <a href="http://www.cnblogs.com/wuyuegb2312/tag/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a></div>
<div id="blog_post_info"><div id="green_channel">
<a href="javascript:void(0);" id="green_channel_digg" onclick="DiggIt(3281264,cb_blogId,1);green_channel_success(this,'谢谢推荐！');">好文要顶</a>
<a id="green_channel_follow" onclick="c_follow();" href="javascript:void(0);">关注我</a>
<a id="green_channel_favorite" onclick="AddToWz(cb_entryId);return false;" href="javascript:void(0);">收藏该文</a><a id="green_channel_contact" href="http://msg.cnblogs.com/send/%E4%BA%94%E5%B2%B3" target="_blank">联系我</a>
<a id="green_channel_weibo" href="javascript:void(0);" title="分享至新浪微博" onclick="ShareToTsina()"><img src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/icon_weibo_24.png" alt=""></a>
<a id="green_channel_wechat" href="javascript:void(0);" title="分享至微信" onclick="shareOnWechat()"><img src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/wechat.png" alt=""></a>
</div>
<div id="author_profile">
<div id="author_profile_info" class="author_profile_info">
<a href="http://home.cnblogs.com/u/wuyuegb2312/" target="_blank"><img src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/u228024.jpg" class="author_avatar" alt=""></a>
<div id="author_profile_detail" class="author_profile_info">
<a href="http://home.cnblogs.com/u/wuyuegb2312/">五岳</a><br>
<a href="http://home.cnblogs.com/u/wuyuegb2312/followees">关注 - 14</a><br>
<a href="http://home.cnblogs.com/u/wuyuegb2312/followers">粉丝 - 419</a>
</div>
</div>
<div class="clear"></div>
<div id="author_profile_honor"></div>
<div id="author_profile_follow">
    <a href="javascript:void(0);" onclick="c_follow();return false;">+加关注</a>
</div>
</div>
<div id="div_digg">										
    <div class="diggit" onclick="votePost(3281264,'Digg')">
        <span class="diggnum" id="digg_count">14</span>
    </div>
	<div class="buryit" onclick="votePost(3281264,'Bury')"> 
		<span class="burynum" id="bury_count">0</span>
	</div>
	<div class="clear"></div>	
	<div class="diggword" id="digg_tips">
    (请您对文章做出评价)
    </div>	
</div>
</div>
<div class="clear"></div>
<div id="post_next_prev"><a href="http://www.cnblogs.com/wuyuegb2312/p/3273337.html" class="p_n_p_prefix">« </a> 上一篇：<a href="http://www.cnblogs.com/wuyuegb2312/p/3273337.html" title="发布于2013-08-30 11:40">全面解析回溯法：算法框架与问题求解</a><br><a href="http://www.cnblogs.com/wuyuegb2312/p/3302561.html" class="p_n_p_prefix">» </a> 下一篇：<a href="http://www.cnblogs.com/wuyuegb2312/p/3302561.html" title="发布于2013-09-13 17:03">编程实践中C语言的一些常见细节</a><br></div>
</div>


		<p class="postfoot">
			posted on <span id="post-date">2013-09-11 10:13</span> <a href="http://www.cnblogs.com/wuyuegb2312/">五岳</a> 阅读(<span id="post_view_count">13347</span>) 评论(<span id="post_comment_count">2</span>)  <a href="http://i.cnblogs.com/EditPosts.aspx?postid=3281264" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(3281264);return false;">收藏</a>
		</p>
	</div>
	<script type="text/javascript">var allowComments=true,isLogined=false,cb_blogId=80216,cb_entryId=3281264,cb_blogApp=currentBlogApp,cb_blogUserGuid='03b9a8f9-1a00-e011-ac81-842b2b196315',cb_entryCreatedDate='2013/9/11 10:13:00';loadViewCount(cb_entryId);</script>
	
</div><a name="!comments"></a><div id="blog-comments-placeholder"><div id="comments_pager_top"></div>
<a name="评论"></a>
<div id="comments">
<h3>评论</h3>
	
	
			<h4>
				<a href="#2773906" class="layer">#1楼</a><a name="2773906" id="comment_anchor_2773906"></a>
					<span>
						 <span class="comment_date">2013-09-12 09:36</span>
					</span>
				<a id="a_comment_author_2773906" href="http://home.cnblogs.com/u/567141/" target="_blank">sudox</a> <a href="http://msg.cnblogs.com/send/sudox" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</h4>
			<p>
				</p><div id="comment_body_2773906" class="blog_comment_body">问题11，有点问题把。用Max[y-1][i][j][k]表示在y-1行时，三条路线分别在i、j、k时所能取得的最大苹果数。(y-1，i)可以走到（y-1,i+1），这种情况考虑了吗？</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(2773906,'Digg',this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(2773906,'Bury',this)">反对(0)</a></div>
				&nbsp;&nbsp;<span class="comment_actions"></span>
			<p></p>
		
			<h4>
				<a href="#2774094" class="layer">#2楼</a><a name="2774094" id="comment_anchor_2774094"></a>[<span class="louzhu">楼主</span>]<span id="comment-maxId" style="display:none;">2774094</span><span id="comment-maxDate" style="display:none;">2013/9/12 12:02:49</span>
					<span>
						 <span class="comment_date">2013-09-12 12:02</span>
					</span>
				<a id="a_comment_author_2774094" href="http://www.cnblogs.com/wuyuegb2312/" target="_blank">五岳</a> <a href="http://msg.cnblogs.com/send/%E4%BA%94%E5%B2%B3" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</h4>
			<p>
				</p><div id="comment_body_2774094" class="blog_comment_body"><a href="#2773906" title="查看所回复的评论" onclick="commentManager.renderComments(0,50,2773906);">@</a>
sudox<br>原文有个笔误，把“ i' ”写成了“ x' ”，即先求最右边k'的所有情况，然后是j'，最后才是i'，重叠时也考虑到了，那个i' = i to j' 表示i'取值为[i,j']这个闭区间的整数。<br>两条线路仅重叠而不交错即为i' = j'的情况；<br>交错时按照图中转化为不交错不重叠或者仅重叠的情况</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(2774094,'Digg',this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(2774094,'Bury',this)">反对(0)</a></div><span id="comment_2774094_avatar" style="display:none;">http://pic.cnblogs.com/face/u228024.jpg?id=17163218</span>
				&nbsp;&nbsp;<span class="comment_actions"></span>
			<p></p>
		
</div><div id="comments_pager_bottom"></div></div><script type="text/javascript">var commentManager = new blogCommentManager();commentManager.renderComments(0);</script>
<div id="comment_form" class="commentform">
<a name="commentform"></a>
<div id="divCommentShow"></div>
<div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>
<div id="comment_form_container"><div class="login_tips">注册用户登录后才能发表评论，请 <a rel="nofollow" href="javascript:void(0);" class="underline" onclick="return login('commentform');">登录</a> 或 <a rel="nofollow" href="javascript:void(0);" class="underline" onclick="return register();">注册</a>，<a href="http://www.cnblogs.com/">访问</a>网站首页。</div></div>
<div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
<div id="ad_t2"><a href="http://www.ucancode.com/index.htm" target="_blank">【推荐】50万行VC++源码: 大型组态工控、电力仿真CAD与GIS源码库</a><br><a href="http://www.rongcloud.cn/" target="_blank">【推荐】融云即时通讯云－豆果美食、Faceu等亿级APP都在用</a><br><a href="http://group.cnblogs.com/topic/75069.html" target="_blank">【福利】你是我的好朋友，我要送你个天猫红包</a><br></div>
<div id="opt_under_post"></div>
<div id="ad_c1" class="c_ad_block"><a href="http://www.gcpowertools.com.cn/products/spreadjs/?utm_source=cnblogs&amp;utm_medium=blogpage&amp;utm_term=bottom&amp;utm_content=SpreadJS&amp;utm_campaign=community" target="_blank"><img src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/24442-20160630110700952-722310635.gif" alt="" height="250" width="300"></a></div>
<div id="under_post_news"><div class="itnews c_ad_block"><b>最新IT新闻</b>:<br> ·  <a href="http://news.cnblogs.com/n/549507/" target="_blank">微软确认Win 10大更计划 接不到推送别急</a><br> ·  <a href="http://news.cnblogs.com/n/549506/" target="_blank">猫眼发布人工智能票房预测服务“阿尔法猫”</a><br> ·  <a href="http://news.cnblogs.com/n/549505/" target="_blank">360再推手机新品，外观让人脸盲，但性价比是真高</a><br> ·  <a href="http://news.cnblogs.com/n/549503/" target="_blank">曾经的知乎，再也回不来了</a><br> ·  <a href="http://news.cnblogs.com/n/549504/" target="_blank">百度设立百金交 布局金融资产交易</a><br>» <a href="http://news.cnblogs.com/" title="IT新闻" target="_blank">更多新闻...</a></div></div>
<div id="ad_c2" class="c_ad_block"><a href="https://www.jiguang.cn/?from=cnblogs01" target="_blank"><img src="11%20%20%20%20%20%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%992%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B1%82%E8%A7%A3%20-%20%E4%BA%94%E5%B2%B3%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD_files/24442-20160613130538213-1713265809.jpg" alt="" height="60" width="468"></a></div>
<div id="under_post_kb"><div class="itnews c_ad_block" id="kb_block"><b>最新知识库文章</b>:<br><div id="kb_recent"> ·  <a href="http://kb.cnblogs.com/page/548394/" target="_blank">如何给变量取个简短且无歧义的名字</a><br> ·  <a href="http://kb.cnblogs.com/page/549080/" target="_blank">编程的智慧</a><br> ·  <a href="http://kb.cnblogs.com/page/549049/" target="_blank">写给初学前端工程师的一封信</a><br> ·  <a href="http://kb.cnblogs.com/page/544641/" target="_blank">抽象：程序员必备的能力</a><br> ·  <a href="http://kb.cnblogs.com/page/213197/" target="_blank">编程同写作，写代码只是在码字</a><br></div>» <a href="http://kb.cnblogs.com/" target="_blank">更多知识库文章...</a></div></div>
<div id="HistoryToday" class="c_ad_block"></div>
<script type="text/javascript">
$(function () {
    setTimeout(function () { incrementViewCount(cb_entryId); }, 50);
    deliverAdT2();
    deliverAdC1();
    deliverAdC2();    
    loadNewsAndKb();
    loadBlogSignature();
    LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
    GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate);
    loadOptUnderPost();
    GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);    
});
</script>
</div>


</div>

<p id="footer">
	Powered by: 
	<br>
	
	<a id="Footer1_Hyperlink3" name="Hyperlink1" href="http://www.cnblogs.com/" style="font-family:Verdana;font-size:12px;">博客园</a>
	<br>
	Copyright © 五岳
</p>
<!--PageEndHtml Block Begin-->
<div style="position:fixed; right:2px; bottom:0px;"><a href="#">回到顶部</a></div>
<!--PageEndHtml Block End-->


</body></html>